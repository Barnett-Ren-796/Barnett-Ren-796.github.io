<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[欧拉回路-学习]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[定义欧拉路径（欧拉通路）：通过图中所有边的简单路。（换句话说，每条边都通过且仅通过一次）也叫”一笔画”问题。欧拉回路：闭合的欧拉路径。（即一个环，保证每条边都通过且仅通过一次）欧拉图：包含欧拉回路的图。 起源在一个图中求解一条欧拉回路的问题，起源于欧拉提出的、著名的“七桥问题”。详见百度百科。 判定欧拉路径： 1.图G是连通的，无孤立点。2.无向图奇点数为0或2，并且这两个奇点其中一个为起点另外一个为终点。有向图，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。 欧拉回路 1.图G是连通的，无孤立点。2.无向图奇点数为0；有向图每个点的入度必须等于出度。 算法求欧拉回路的算法中，普遍使用的是Fleury算法和Hierholzer算法。由于Hierholzer算法在时间复杂度和代码实现上都更优，所以这里只介绍一下Hierholzer算法。主要是我不会敲Fleury…… Hierholzer算法思路 1.根据每个点的入度选择起点。2.运用DFS去遍历当前节点的每一条边，之后将该节点压入栈中。3.操作2接受后，栈中的元素就是一条欧拉回路。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define INF 0x7fffffff#define ll long longusing namespace std;int n,m,x,y,head[1200],cnt,map[1030][1030],d[1030],begin,s[1030],t;void dfs(int k)&#123; for(register int i = 1; i &lt;= n; i++) &#123; if(map[k][i] &gt; 0) &#123; map[k][i] --; map[i][k] --; dfs(i); &#125; &#125; s[++t] = k;&#125;int main()&#123; scanf("%d",&amp;m); for(register int i = 1; i &lt;= m; i++) &#123; scanf("%d%d",&amp;x,&amp;y); map[x][y] ++; map[y][x] ++; n = max(n,x); n = max(n,y); d[x] ++; d[y] ++; &#125; for(register int i = 1; i &lt;= n; i++) &#123; if(d[i] % 2 == 1) &#123; begin = i; break; &#125; &#125; if(begin == 0) begin = 1; dfs(begin); for(register int i = t; i &gt;0; i--) printf("%d\n",s[i]); printf("\n"); return 0;&#125; 推荐联系题目：骑马修栅栏、无序字母对]]></content>
      <tags>
        <tag>欧拉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层图最短路-学习]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ARX：我今天上午做了两个分层图最短路的题，可简单了……概念 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 算法思路这是一个类似于DP的思路。用直接通过的边把整个图分成k个子图，其中k为可以直接通过的边的个数。在此基础上，我们直接跑最短路算法就可以了。 算法细节在处理子图与子图之间的关系时，由于连接两个子图的路径是可以直接通过的，所以我们在记录下一层的路径长度时，转移方程为:if(d[edge[i].to][level + 1] &lt; d[u][level] &amp;&amp; level &lt; k) d[edge[i].to][level + 1] = d[u][level];其中edge[i]是一条以节点u为起点的边。注意，由于图的层数有限，所以level &lt; k这一条件一定不要忘记加。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node&#123; int k,dis,used; bool operator &lt; ( const node &amp;x )const&#123;return x.dis &lt; dis;&#125;&#125;;priority_queue&lt;node&gt; que;long long n,m,k,s,t,d[50005],cnt,D[50005][15],v[50005][15]; struct Edge&#123; int to,next,x;&#125;edge[2000005];void add(int x,int y,int a)&#123; edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;&#125;int main()&#123; int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); scanf("%d%d",&amp;s,&amp;t); for(register int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); add(y,x,a); &#125; que.push((node)&#123;s,0,0&#125;); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) &#123; node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) &#123; int too = edge[i].to; if(D[too][level] &gt; D[kk][level] + edge[i].x) &#123; D[too][level] = edge[i].x + D[kk][level]; que.push((node)&#123;too,D[too][level],level&#125;); &#125; if(level &lt; k &amp;&amp; D[too][level + 1] &gt; D[kk][level]) &#123; D[too][level + 1] = D[kk][level]; que.push((node)&#123;too,D[too][level + 1],level + 1&#125;); &#125; &#125; &#125; long long ans = INF; for(register int i = 0; i &lt;= k; i++) ans = min(ans,D[t][i]); printf("%lld\n",ans); return 0;&#125; 推荐练习题目：飞行路线、冻结、回家的路]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra-学习]]></title>
    <url>%2F2019%2F06%2F20%2FDijkstra-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言SPFA算法由于它上限O(NM)的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:dijkstra 什么是dijkstra?dijkstra是一种单源最短路径算法,时间复杂度上限为O(n^2)(朴素),在实际应用中较为稳定;加上堆优化之后更是具有O((n+m)log^2 n)的时间复杂度,在稠密图中有不俗的表现. dijkstra的原理/流程?dijkstra本质上的思想是贪心,它只适用于不含负权边的图.我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” dijkstra的流程如下: 初始化dis[start] = 0,其余节点的dis值为无穷大. 找一个dis值最小的蓝点x,把节点x变成白点. 遍历xx的所有出边(x,y,z)，若dis[y] &gt; dis[x] + z,则令dis[y] = dis[x] + z 重复2,3两步,直到所有点都成为白点.dijkstra为什么是正确的当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第2步中找出的蓝点x必然满足:dis[x]已经是起点到x的最短路径.我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度图解(令start = 1)开始时我们把dis[start]初始化为0,其余点初始化为inf第一轮循环找到dis值最小的点1,将1变成白点,对所有与1相连的蓝点的dis值进行修改,使得dis[2]=2,dis[3]=4,dis[4]=7第二轮循环找到dis值最小的点2,将2变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[3]=3,dis[5]=4第三轮循环找到dis值最小的点3,将3变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[4]=4接下来两轮循环分别将4,5设为白点,算法结束,求出所有点的最短路径 为什么dijkstra不能处理有负权边的情况?我们来看下面这张图2到3的边权为−4,显然从1到3的最短路径为−2 (1-&gt;2-&gt;3).但在循环开始时程序会找到当前dis值最小的点3,并标记它为白点.这时的dis[3]=1,然而1并不是起点到3的最短路径.因为3已经被标为白点,所以dis[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. dijkstra的堆优化?观察dijkstra的流程,发现步骤2可以优化怎么优化呢?我们可以用堆对disdis数组进行维护,用O(logn)的时间取出堆顶元素并删除,用O(logn)的时间遍历每条边,总复杂度O((n+m)\log^2 n).附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node&#123; int k,dis; bool operator &lt; ( const node &amp;x )const&#123;return x.dis &lt; dis;&#125;&#125;;priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge&#123; int to,next,x;&#125;edge[2000005];void add(int x,int y,int a)&#123; edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;&#125;int main()&#123; int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); &#125; que.push((node)&#123;s,0&#125;); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) &#123; node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) &#123; if(D[edge[i].to] &gt; D[u.k] + edge[i].x) &#123; D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node)&#123;edge[i].to,D[edge[i].to]&#125;); &#125; &#125; &#125; for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化-学习]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[·什么是离散化？离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。 ·为什么要用、什么时候要用离散化呢？如果让你吧1000个1到1000的数放到桶里，那么非常简单，直接开一个大小为1000的数组，然后在里面统计就可以了。但是，如果吧这1000个数的大小改为1到1000000000呢？很显然，直接开一个大小为1000000000的数组去统计是不现实的，直接MLE。这时，我们就需要用到离散化了。（当然，这只是一个小例子） ·我们怎么去实现离散化呢？对于一个数组a，我们可以用另外一个数组去记录其中每个数的大小关系（如数字b在a中为第k大），这样就可以在新得到的数组中查询每个数的大小关系。这样，我们就达到了离散化的目的。而且，我们可以利用这个大小关系来得到之前原数组对应位置的数字。 ·具体该怎么用代码实现呢？为了实现离散化，我们需要用到unique和lower_bound这两个函数。 uniqueunique可以统计某数组中不同元素的个数，如我们想用cnt去记录长度为n的数组a中有几个不同的元素，则可以用到unique，代码为 cnt = unique(a + 1, a + n + 1) - a - 1lower_bound其实还有一个叫upper_bound的函数 lower_bound可以返回某个元素在某个数组中是第几大的。例如，如你想用ans去记录数字b在长度为n数组a中是第几大的，那么就可以通过lower_bound去实现，代码为 ans = lower_bound(a + 1, a + n + 1, b) - a;附一下完整代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,cnt,ans,a[1000],b[1000],x[1000];int mysort(int a,int b) &#123;return a &lt; b;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; //输入 for(int i = 1; i &lt;= n; i++) x[i] = a[i]; //用x记录a，方便后续操作 sort(x + 1, x + n + 1, mysort); //排序 对于统计来书可有可无，但方便去重和还原 cnt = unique(x + 1, x + n + 1) - x - 1; //统计x中不同颜色的个数 for(int i = 1; i &lt;= n; i++) b[i] = lower_bound(x + 1, x + n + 1, a[i]) - x; //统计每个元素在原数组的大小位置 cout &lt;&lt; "cnt = " &lt;&lt; cnt &lt;&lt; endl; //查看不同元素的个数 for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; " "; //查看离散化后的数组 cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; x[b[i]] &lt;&lt; " "; //还原数组a cout &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树-学习]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言：线段树是一种二叉搜索树，能通关TA实现修改、区间查询等功能……（ 相信大家都懂的……）好吧，在这里，我们就来介绍线段树的单点修改、区间修改以及区间查询的方法。 单点修改，区间查询Emmmmmm 这算是学习线段树的第一步了吧…… _为什么要用线段树去干这件事情呢？你会发现，如果你直接暴力去查询一个区间 [l,r] 的和，那么这样做的时间复杂度将会使O(n)的；但是，如果你用线段树去实现这一过程，那么时间复杂度将会降成O(log n)。 _ 接下来我们就来讲算法的原理。既然线段树被称为“树”，自然是一种树状的数据结构。它的每一个节点都储存了某一个区间的信息。它的结构如图所示： 进行修改时，我们需要更新指定修改节点已经所以与其相关的区间（即包含此节点的所有区间），查询时需查询的区间的值可以有其内部的几个区间的值拼起来得到。代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;cstdio&gt;using namespace std;struct tree&#123; int sum; tree *lson,*rson;&#125;*root=(tree*)malloc(sizeof(tree));int n,x,y,s,m;void built(tree *tre,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;x); tre -&gt; sum = x; return ; &#125; tree *left=(tree*)malloc(sizeof(tree)); tree *right=(tree*)malloc(sizeof(tree)); tre -&gt; lson=left; tre -&gt; rson=right; int mid=(l+r)&gt;&gt;1; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid+1,r); tre -&gt; sum=tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;&#125;void change(tree *tre,int a,int x,int l,int r)&#123; if(x==l&amp;&amp;x==r) &#123; tre -&gt; sum+=a; return ; &#125; tre -&gt; sum += a; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(tre -&gt; lson,a,x,l,mid); if(x&gt;mid) change(tre -&gt; rson,a,x,mid+1,r);&#125;int query(tree *tre,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r) return tre -&gt; sum; int mid=(l+r)&gt;&gt;1,ans1=0,ans2=0; if(x&lt;=mid) ans1=query(tre -&gt; lson,l,mid,x,y); if(y&gt;mid) ans2=query(tre -&gt; rson,mid+1,r,x,y); return ans1+ans2;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); built(root,1,n); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;s,&amp;x,&amp;y); if(s==1) change(root,y,x,1,n); if(s==2) printf("%d\n",query(root,1,n,x,y)); &#125; return 0;&#125;// PS:我的线段树是用指针写的，如果不喜欢指针可以用数组去实现，节点N的左孩子的下标为2N，右孩子的下标为2N+1。 想做模板题请戳这里（请忽略题目名字，并不是我弄错了，一个模板题的潜力是无穷的） 区间修改，区间查询其实区间修改与单点修改之间只差了一个lazy标记……如果你用多次的单点修改来完成区间修改，那么复杂度将会是O（nlogn），显然还不如你直接修改一个数组快qwq……所以在这个紧急关头，你需要一个lazy标记去拯救你。对于每次区间修改，我们还是从根节点开始找每一个区间，若当前区间[l,r]被需要修改的区间[x,y]完全包含，那么在更新此区间的值的同时，我们还要更新lazy标记，表示该节点的两个子节点需要进行一个大小为lazy的值的修改，但是现在还没有进行。当你打完lazy标记以后，在此次修改中，你就不必再去观该节点的子树了。那么，既然我们打了lazy标记，那么以后肯定还是需要让它起作用的。我们在每次修改和查询过程中，若遍历到某点时，该点的lazy标记不为0，则把标记下放（即根据该节点的lazy标记值去修改其子节点的值，并把该节点的lazy加到其子节点的lazy上。注意，lazy的是加过去，而不是直接覆盖！在标记下放完以后，不要忘了把该节点的lazy标记清空）。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct tree&#123; long long sum,lazy; tree *lson,*rson; tree() &#123; lazy = 0; &#125;&#125;;long long x,y,k,n,m,s;void built(tree *tre,int l,int r)&#123; tre -&gt; lazy = 0; if(l == r) &#123; scanf("%d",&amp;x); tre -&gt; sum = x; return ; &#125; int mid = (l + r) &gt;&gt; 1; tree *son1 =(tree*) malloc (sizeof(tree)); tree *son2 =(tree*) malloc (sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid + 1,r); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;&#125;void pushdown(tree *tre,int l,int r)&#123; if(l != r) &#123; int mid = (l + r) &gt;&gt; 1; tre -&gt; lson -&gt; lazy = tre -&gt; lson -&gt; lazy + tre -&gt; lazy; tre -&gt; lson -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; lazy * (mid - l + 1); tre -&gt; rson -&gt; lazy = tre -&gt; rson -&gt; lazy + tre -&gt; lazy; tre -&gt; rson -&gt; sum = tre -&gt; rson -&gt; sum + tre -&gt; lazy * (r - mid); &#125; tre -&gt; lazy = 0;&#125;void change(tree *tre,int l,int r,int x,int y,int k)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) &#123; tre -&gt; lazy += k; tre -&gt; sum = tre -&gt; sum + k * (r - l + 1); return ; &#125; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(tre -&gt; lson,l,mid,x,y,k); if(y &gt; mid) change(tre -&gt; rson,mid + 1,r,x,y,k); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt;sum;&#125;long long query(tree *tre,int l,int r,int x,int y)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) return tre -&gt; sum; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; long long t1 = 0,t2 = 0; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return t1 + t2;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); tree *root = (tree*) malloc (sizeof(tree)); built(root,1,n); for(int i = 1;i &lt;= m; i++) &#123; scanf("%lld%lld%lld",&amp;s,&amp;x,&amp;y); if(s == 1) &#123; scanf("%lld",&amp;k); change(root,1,n,x,y,k); &#125; else &#123; long long ans = query(root,1,n,x,y); printf("%lld\n",ans); &#125; &#125; return 0;&#125; 想做模板题请戳这里 线段树除了求和还能干好多事情（如维护区间最大值等），可以自行YY一下下……]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树-学习]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[隔了几个月，又开始写博客了qwq kruskal时间复杂度为O(nlogn)它的算法思路是这样的：我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,q[6000];struct lalala&#123; int x,y,z,save;&#125;a[210000];int mysort(lalala a,lalala b)&#123; return a.z &lt; b.z;&#125;int work(int x,int y)&#123; while(q[q[x]] != q[x]) q[x] = q[q[x]]; while(q[q[y]] != q[y]) q[y] = q[q[y]]; if(q[x] == q[y]) return 1; else &#123; q[q[y]] = q[x]; return 0; &#125;&#125;int main()&#123; long long ans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) q[i]=i; for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z; ans += a[i].z; &#125; sort(a+1,a+m+1,mysort); for(int i=1;i&lt;=m;i++) &#123; if(!work(a[i].x,a[i].y)) ans -= a[i].z; &#125; cout &lt;&lt; ans; return 0;&#125; prim时间复杂度O(n2)跑得慢，代码长，没特殊功能，真不知道为什么要学它qwq……prim的思想和某最短路算法的思路是类似的，我们将更新过的点标为白色，没有更新过的标为蓝色，然后枚举每一个蓝点（按minn值从小到大更新，这里貌似可以用堆优化，然而我比较懒qwq）并更新为白点，并用它去更新其他的蓝点（这里不用把被更新的点标为白色，不然它们就没法更新其他点，也没法被其他的点更新了）。最后将每个点的minn值加起来就好啦。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node&#123; int k,dis; bool operator &lt; ( const node &amp;x )const&#123;return x.dis &lt; dis;&#125;&#125;;priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge&#123; int to,next,x;&#125;edge[2000005];void add(int x,int y,int a)&#123; edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;&#125;int main()&#123; int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); &#125; que.push((node)&#123;s,0&#125;); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) &#123; node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) &#123; if(D[edge[i].to] &gt; D[u.k] + edge[i].x) &#123; D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node)&#123;edge[i].to,D[edge[i].to]&#125;); &#125; &#125; &#125; for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;&#125; prim的堆优化既然prim和某最短路算法的思路是相似的，那么ta和某最短路算法一样也可以用堆优化，可以把时间复杂度从O(n2)降到O(nlongn)依然是跑得慢，代码长，没特殊功能qwq……附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;struct edge&#123; int x,y,z;&#125;a[500005];struct EDGE&#123; int next,to,x,save;&#125;e[500005];struct node&#123; int k,dis; bool operator &lt; (const node &amp; x) const &#123;return x.dis &lt; dis;&#125;&#125;now;priority_queue &lt;node&gt; que;int cnt,d[100005];void add(int x,int y,int a)&#123; e[++cnt].to = y; e[cnt].x = a; e[cnt].next = d[x]; d[x] = cnt;&#125;int n,m,q,x,y,z,ans,minn[100005],vis[100005];int mysort(edge a1, edge a2)&#123; if(a1.x != a2.x) return a1.x &lt; a2.x; if(a1.y != a2.y) return a1.y &lt; a2.y; return a1.z &lt; a2.z;&#125;int main()&#123; n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) &#123; a[i].x = read(); a[i].y = read(); a[i].z = read(); &#125; sort(a + 1, a + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) if(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) &#123; add(a[i].x, a[i].y, a[i].z); add(a[i].y, a[i].x, a[i].z); &#125; for(re int i = 1; i &lt;= n; i++) minn[i] = INF; que.push((node)&#123;1,0&#125;); while(!que.empty()) &#123; now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = d[now.k]; i; i = e[i].next) if(!vis[e[i].to] &amp;&amp; e[i].x &lt; minn[e[i].to]) &#123; minn[e[i].to] = e[i].x; que.push((node)&#123;e[i].to,minn[e[i].to]&#125;); &#125; &#125; for(re int i = 2; i &lt;= n; i++) ans = ans + minn[i]; printf("%d\n",ans); return 0;&#125; 推荐例题：【模板】最小生成树]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>prim</tag>
        <tag>kruskal</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缺省源]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%BC%BA%E7%9C%81%E6%BA%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int main()&#123; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[无线通讯网-题解]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%97%A0%E7%BA%BF%E9%80%9A%E8%AE%AF%E7%BD%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[直到敲完这个题，我才发现原来prim如果用邻接矩阵存图即使加上堆优化时间复杂度依然是O(n2)qwq…… 首先，由于两个点只需要间接联通就可以互相通讯，所以这道题可以用最小生成树去做。这一步比较好完成。 问题在于怎么去加卫星电话。由于两个点只要间接联通就可以，那么每一个用无线电收发器连成的子图只需要有一个卫星电话即可与其它的点联通，所以我们在删边的时候需要先判断一下这两个点删完边以后是不是仍然联通而不是傻傻地给这两个点都安装上卫星电话（被这个卡了好久qwq） 如图所示，由于2、4号点都安装了电话，所以删掉边1-3后，1、3号点之间就不需要安装电话的。 再来看如何安装电话。如图，我们可以发现，当前两个点安装完卫星电话以后，每一个子图都会拥有一个卫星电话。当我们继续删边时，分成的两个新的子图都是一个有卫星电话，一个没有，所以我们从第二次开始每次删边只需要增加一部卫星电话即可。所以最终留下的最大的边是第s大的边（由于第一次删边你需要安装两台卫星电话，所以你最多只能删s - 1条边）附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;struct NODE&#123; int x, y, num; double minn;&#125;a[1000];int s,p,vis[1000],del[1000],fa[1000],f[1000];struct node&#123; int k; double dis; bool operator &lt; ( const node &amp;x )const&#123;return x.dis &lt; dis;&#125;&#125;;priority_queue &lt;node&gt; que;int mysort(NODE a, NODE b)&#123;return a.minn &gt; b.minn;&#125;int main()&#123; s = read(); p = read(); for(re int i = 1; i &lt;= p; i++) &#123; a[i].x = read(); a[i].y = read(); a[i].num = i; &#125; for(re int i = 1; i &lt;= p; i++) a[i].minn = INF; que.push((node)&#123;1,0&#125;); vis[1] = 1;a[1].minn = 0; while(!que.empty()) &#123; node now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = 1; i &lt;= p; i++) &#123; if(!vis[i] &amp;&amp; sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))) &lt; a[i].minn) &#123; a[i].minn = sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))); que.push((node)&#123;i,a[i].minn&#125;); fa[i] = now.k; &#125; &#125; &#125; sort(a + 1, a + p + 1, mysort); int j = 1; double Min = a[j].minn; Min = a[s].minn; printf("%.2lf\n",Min); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant Trip-题解]]></title>
    <url>%2F2019%2F06%2F20%2FAnt-Trip-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里因为每条边都只能走一次，所以这道题可以用欧拉路的性质来求解。我们首先用并查集去记录每一个联通块，然后再统计每一个子图的奇点数，如果是偶数则满足欧拉回路的性质直接ans++ 就好了，如果是奇数，那么需要的蚂蚁数则是奇点数/2附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register using namespace std;int read()&#123; register int a = 0,f = 1; register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &lt;='9' &amp;&amp; ch &gt;='0') &#123;a = a * 10 + ch - 48; ch = getchar();&#125; return a * f;&#125;int n,m,x,y,s,ans,cnt,t,d[100005],fa[100005],use[100005],a[100005],add[100005];int find(int p)&#123; if(fa[p] == p) return p; return fa[p] = find(fa[p]);&#125;void work()&#123; m = read(); ans = 0; for(re int i = 1; i &lt;= n; i++) fa[i] = i; for(re int i = 1; i &lt;= n; i++) d[i] = 0; for(re int i = 1; i &lt;= n; i++) a[i] = 0; for(re int i = 1; i &lt;= n; i++) add[i] = 0; for(re int i = 1; i &lt;= m; i++) &#123; x = read(); y = read(); d[x] ++; d[y] ++; if(find(x) != find(y)) fa[find(y)] = find(x); &#125; for(int i = 1; i&lt;= n; i++) &#123; a[find(i)]++; if(d[i] % 2 == 1) add[find(i)] ++; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt;= 1) continue; //只有一个点和空的点集没有边，可以忽略不计。 else if(add[i] == 0) ans += 1; else if(add[i] &gt; 0) ans += add[i]/2; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; while(cin &gt;&gt; n) work(); return 0;&#125;]]></content>
      <tags>
        <tag>欧拉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路计数-题解]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 虽然题目叫最短路计数，但是TA可以只用到最短路的概念而不用最短路的算法……由于这是一个无权图，所以一条路径上边的数量就是这条路径的长度，那么我们就可以用BFS来搞定这个问题了。 具体思路我们每遍历到一个节点就和ta的前一个结点的距离比较，这里会有三种情况：(由1到2) 2号点没有被访问过||time[1] + 1 &lt; time[2]：此时我们直接用1号点的信息去更新2就好啦 time[1] + 1 = time[2] : 这个我们就只需要更新一下ans就可以啦 time[1] + 1 &gt; time[2] :此时这条路径比之前的某条路径要长，直接跳过就可以啦代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;queue&lt;int&gt; que;struct edge&#123; int next,to,v;&#125;e[2000005];int n,m,cnt,x,now,y,tim[2000000],ans[2000000],d[2000000];inline int add(int x,int y)&#123; e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;int main()&#123; n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) &#123; x = read(); y = read(); add(x,y); add(y,x); &#125; que.push(1); ans[1] = 1; while(!que.empty()) &#123; now = que.front(); que.pop(); for(re int i = d[now]; i; i = e[i].next) &#123; if(tim[now] + 1 &lt; tim[e[i].to] || tim[e[i].to] == 0) &#123; tim[e[i].to] = tim[now] + 1; ans[e[i].to] = ans[now]; que.push(e[i].to); &#125; else if(tim[now] + 1 == tim[e[i].to]) ans[e[i].to] = (ans[e[i].to] + ans[now]) % 100003; &#125; &#125; ans[1] = 1; for(re int i = 1; i &lt;= n; i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
</search>
