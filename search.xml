<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[车站分级-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题戳这里 一道有趣的建图题qxy当时做了好久才发现自己图建错了qwq看到“如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠”后，大家有没有感到一丝丝熟悉呢？ 没错，这个条件和拓扑排序的条件很相似所以，我们只需要把所有的车站放到一个图中，在用一个类似于拓扑排序的算法去更新答案就可以了。 那么，具体该怎么建图呢？建图是这个题的难点，但其实原理非常简单。首先，对于每一班车，它提供的信息只对它的起点(a)到终点(b)这一段有效而并非对全部有效。其次，因为“如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠”，所以在区间[a,b]中这趟车停过的点的级别一定高于没有停的点的级别。根据拓扑排序的要求，我们只需要从没有停下的点向每一个停下的点连一条有向边就可以了。ps：为了卡你，出题人一定对把图搞得很稠密，所以存图的时候需要优化一下时间复杂度。附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int head,tail,n,s,Max,t,m,c[1001],bus[1001],f[1001][1001],que[1001],d[1001],u[1001],stop[1001]; void work(){ while(head &lt; tail) { head++; for(int i = 1; i &lt;= n; i++) if(f[que[head]][i]) { d[i] –; u[i] = u[que[head]] + 1; Max = max(Max,u[i]); if(d[i] == 0) que[++tail] = i; } }} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) u[i] = 0x7fffffff; for(int i = 1; i &lt;= m; i++) { scanf(“%d”,&amp;s); memset(c,0,sizeof(c)); t = 0; for(int j = 1; j &lt;= s; j++) scanf(“%d”,&amp;bus[j]); for(int j = 1; j &lt;= s; j++) c[bus[j]] = 1; for(int j = bus[1]; j &lt;= bus[s]; j++) if(!c[j]) stop[++t] = j; for(int j = 1; j &lt;= s; j++) for(int k = 1; k &lt;= t; k++) { if(!f[stop[k]][bus[j]]) //没连边 { f[stop[k]][bus[j]] = 1; d[bus[j]] ++; } } } for(int i = 1; i &lt;= n; i++) if(!d[i]) { que[++tail] = i; u[i] = 1; } work(); printf(“%d”,Max); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[夏令营]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%A4%8F%E4%BB%A4%E8%90%A5%2F</url>
    <content type="text"><![CDATA[数论取整 x是一个实数 floor(x)对x向下取整 ceil(x)对x向上取整 进制转换十进制转m进制用一个数组存转化得到的数，每次将十进制数 %m,得到m进制的最后一位，然后$ / m$，去掉最后一位 m进制转十进制取$v = 0$,每次取m进制数的最高位,使$v = v \times m + a[i]$ 位运算 &lt;&lt; 左移，乘2的n次方 &gt;&gt; 右移，除2的n次方 &amp; 相同位的两个数字都为1，则为1；若有一个不为1，则为0 ·|· 相同位只要一个为1即为1 ^ 操作的结果是如果某位不同则该位为1, 否则该位为0 ~ not运算的定义是把内存中的0和1全部取反 取模基本性质取模可以与加减乘交换顺序（注意除不行） x ≡ y(% p) x+a ≡ y+a (% p) x-a ≡ y-a (% p) （减法需要注意把负数华为正数） xa ≡ ya (% p) (以上假设x≡y (%p)) (a + b)%p = (a%p + b%p)%p (a - b)%p = (a%p – b%p)%p (a - b)%p = (a - b + p)%p ab%p = (a%p)(b%p) %p 正负 一个正整数对一个正整数取模得到的是一个非负整数 一个负数对一个正整数取模得到的是负数或者是0 $a$%$b = a - \lfloor a / b \rfloor * b (a &gt; 0)$ 唯一分解定理唯一分解定理(也称基本算数定理)：任意一个正整数c，将其分解为若干质数的正整数次幂的乘积，该分解方法唯一形如：$c=p1a1p2a2……*pnan$，$p1…pn$均为质数 最大公约数算法公式： code: 1int gcd(int a,int b)&#123;return b == 0 ? a,gcd(b,a % b);&#125; 时间复杂度为$log$级别。 最小公倍数 $lcm=n \times m / gcd(n,m)$ 证明：从质因数分解思考 拓展欧几里得 code： 1234567891011int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b == 0) &#123; x = 1,y = 0; return a; &#125; int g = exgcd(b,a % b,y,x); y -= a / b * x; return g;&#125; 数据结构单调栈 单调栈是指一个栈内部的元素是具有严格单调性的一种数据结构 一般作为工具在预处理数据时使用，或者优化动态规划（决策具有单调性）例题 单调队列 单调队列必须满足从队头到队尾的严格单调性。 排在队列前面的比排在队列后面的要先进队。 一般用于优化动态规划等 例题： code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;malloc.h&gt; #define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;struct tree&#123; int maxx,minn; tree *lson,*rson;&#125;*root = (tree*)malloc(sizeof(tree));struct node&#123; int a,b;&#125;ans[1000005];void build(tree *tre,int l,int r)&#123; if(l == r) &#123; tre -&gt; maxx = read(); tre -&gt; minn = tre -&gt; maxx; return; &#125; int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; maxx = max(tre -&gt; lson -&gt; maxx,tre -&gt; rson -&gt; maxx); tre -&gt; minn = min(tre -&gt; lson -&gt; minn,tre -&gt; rson -&gt; minn);&#125;node query(tree *tre,int l,int r,int x,int y)&#123; if(l == r) return (node)&#123;tre -&gt; maxx,tre -&gt; minn&#125;; int mid = (l + r) &gt;&gt; 1; node t1,t2; t1.a = -INF; t1.b = INF; t2.a = -INF; t2.b = INF; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return (node)&#123;max(t1.a,t2.a),min(t1.b,t2.b)&#125;;&#125;int main()&#123; int n,k; n = read(); k = read(); build(root,1,n); for(int i = 1; i &lt;= n - k + 1; i++) ans[i] = query(root,1,n,i,i + k - 1); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].b); printf("\n"); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].a); printf("\n"); return 0;&#125; 莫队$O(nsqrt(n)\times 修改复杂度)$的分治算法，只需要问题满足支持快速单点插入和快速单点删除就行了 例题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffffusing namespace std;long long read()&#123; long long x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0')&#123;if(ch == '-') f = -f; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;long long gcd(long long a, long long b)&#123;return a == 0 ? b : gcd(b % a, a);&#125;long long n,m,a[50005],xsort,p1,p2,t[50005],ans,cnt,g,ll,rr,in[50005],save1[50005],save2[50005];struct query&#123; long long l,r,num;&#125;q[50005];long long mysort(query x, query y)&#123; if(x.l / xsort == y.l / xsort) return x.r &lt; y.r; return x.l &lt; y.l;&#125;/*inline void del(int k)&#123; if(!in[k]) return ; in[k] = 0; t[a[k]] --; printf("del %d :\n before : %d\n",k,ans); ans = ans - t[a[k]] * (t[a[k]] + 1) + t[a[k]] * (t[a[k]] - 1); printf("after : %d\n",ans);&#125;inline void add(int k)&#123; if(k == 0) return ; if(in[k]) return ; in[k] = 1; t[a[k]] ++; ans = ans + t[a[k]] * 2;&#125;*/long long work(long long x)&#123; return x * x;&#125;void add(long long k)&#123; long long u = a[k]; if(k == 0) return ; //if(in[k]) return ; //in[k] = 1; ans = ans - work(t[u]); t[u] ++; ans = ans + work(t[u]);&#125;void del(long long k)&#123; long long u = a[k]; if(k == 0) return ; //if(in[k] == 0) return ; //in[k] = 0; ans = ans - work(t[u]); t[u] --; ans = ans + work(t[u]);&#125;int main()&#123; n = read(); m = read(); for(re int i = 1; i &lt;= n; i ++) a[i] = read(); for(re int i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].num = i; &#125; xsort = sqrt(n); sort(q + 1, q + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) &#123; ll =q[i].l; rr = q[i].r;// if(ll == rr) &#123;printf("0/1\n"); continue ;&#125; while(p1 &lt; ll)&#123;del(p1); p1 ++;&#125; while(p1 &gt; ll)&#123;p1 --; add(p1);&#125; while(p2 &lt; rr)&#123;p2 ++; add(p2);&#125; while(p2 &gt; rr)&#123;del(p2); p2 --;&#125; cnt = (rr - ll + 1) * (rr - ll); save1[q[i].num] = ans - (rr - ll + 1); save2[q[i].num] = cnt; &#125; for(re int i = 1; i &lt;= m; i++) &#123; if(save1[i] != 0 &amp;&amp; save2[i] != 0) g = gcd(save1[i],save2[i]); else g = 1; if(save1[i] == 0 || save2[i] == 0) &#123;printf("0/1\n"); continue ;&#125; printf("%d/%d\n",save1[i] / g,save2[i] / g); &#125; return 0;&#125; 堆 由于我们有priority_queue,所以手写堆就可以歇着了…… 二叉搜索树 大概就是这样了 由于这东西对于竞赛没什么用（太好卡了，还是去用平衡树吧……），所以不说什么了。 线段树 额…… 对于线段树自我感觉良好，不说废话了qwq。 树链剖分大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”，我们所讲的也是“重链剖分”。 重链剖分可以将树上的任意一条路径划分成不超过O(logn) 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的lca为链的一个端点）。重链剖分还能保证划分出的每条链上的节点 dfs 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。 1.修改 树上两点之间的路径上 所有点的值。2.查询 树上两点之间的路径上 节点权值的 和/极值/其它（在序列上可以用数据结构维护，便于合并的信息） 。 求LCA 如果两个节点不在同一条链上，将所在链链首深度大的点跳链。当在同一条链时，深度小的点的位置就是lca。 一次跳过一条链，速度比倍增快。 用线段树维护区间值 考虑到树链剖分后每一个链的元素的dfs序是连续的，所以我们可以用线段树取维护树链剖分后的序列。 例题： ZJOI2008 树的统计 对一棵有n个节点，节点带权值的静态树，进行三种操作共q 次： 修改单个节点的值； 查询u到u的路径上的最大值； 查询v到v的路径上的权值和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,r,s,p,x,y,z,o,t,cnt,ans;int d[200005],siz[200005],fa[200005],dep[200005],son[200005],top[200005],seg[200005],rev[200005],bs[200005];struct edge&#123; int next,to;&#125;e[300005];struct tree&#123; int sum,lazy; tree *lson,*rson;&#125;*root = (tree*)malloc(sizeof(tree));void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void dfs1(int u,int f)&#123; int a,v; siz[u] = 1; fa[u] = f; dep[u] = dep[f] + 1; for(int i = d[u]; i; i = e[i].next) &#123; int j = e[i].to; if(j == f) continue; dfs1(j,u); siz[u] = siz[u] + siz[j]; if(siz[j] &gt; siz[son[u]]) son[u] = j; &#125;&#125;void dfs2(int u,int f)&#123; if(son[u]) &#123; seg[son[u]] = ++t; top[son[u]] = top[u]; rev[t] = son[u]; dfs2(son[u],u); &#125; for(int i = d[u]; i; i = e[i].next) &#123; int j = e[i].to; if(!top[j]) &#123; top[j] = j; seg[j] = ++t; rev[t] = j; dfs2(j,u); &#125; &#125;&#125;void build(tree *tre,int l,int r)&#123; tre -&gt; lazy = 0; if(l == r) &#123; tre -&gt; sum = bs[rev[l]]; return ; &#125; int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; sum = (tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum) % p;&#125;void pushdown(tree *tre,int l,int r)&#123; if(l == r || tre -&gt; lazy == 0) return ; int mid = (l + r) &gt;&gt; 1; tre -&gt; lson -&gt; sum = (tre -&gt; lson -&gt; sum + 1ll *(mid - l + 1) * tre -&gt; lazy) % p; tre -&gt; rson -&gt; sum = (tre -&gt; rson -&gt; sum + 1LL *(r - mid) * tre -&gt; lazy) % p; tre -&gt; lson -&gt; lazy = (tre -&gt; lson -&gt; lazy + tre -&gt; lazy) % p; tre -&gt; rson -&gt; lazy = (tre -&gt; rson -&gt; lazy + tre -&gt; lazy) % p; tre -&gt; lazy = 0;&#125;void change(tree *tre,int l,int r,int x,int y,int k)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) &#123; tre -&gt; sum = (tre -&gt; sum + 1LL * (r - l + 1) * k) % p; tre -&gt; lazy = (tre -&gt; lazy + k) % p; return ; &#125; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(tre -&gt; lson,l,mid,x,y,k); if(y &gt; mid) change(tre -&gt; rson,mid + 1,r,x,y,k); tre -&gt; sum = (tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum) % p;&#125;int query(tree *tre,int l,int r,int x,int y)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) return tre -&gt; sum; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1,t1 = 0,t2 = 0; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y) % p; if(y &gt;mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y) % p; return (t1 + t2) % p;&#125;void myswap()&#123; o = x; x = y; y = o;&#125;int main()&#123; n = read(); m = read(); r = read(); p = read(); for(int i = 1; i &lt;= n; i++) bs[i] = read(); for(int i = 1; i &lt; n; i++) &#123; x = read(); y = read(); add(x,y); add(y,x); &#125; dfs1(r,0); seg[r] = ++t; rev[t] = r; top[r] = r; dfs2(r,0); build(root,1,n); for(int i = 1; i &lt;= m; i++) &#123; s = read(); ans = 0; if(s == 1) &#123; x = read(); y = read(); z = read(); while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) myswap(); change(root,1,n,seg[top[x]],seg[x],z); x = fa[top[x]]; &#125; if(seg[x] &gt; seg[y]) myswap(); change(root,1,n,seg[x],seg[y],z); &#125; if(s == 2) &#123; x = read(); y = read(); while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) myswap(); ans = (ans + query(root,1,n,seg[top[x]],seg[x])) % p; x = fa[top[x]]; &#125; if(seg[x] &gt; seg[y]) myswap(); ans = (ans + query(root,1,n,seg[x],seg[y])) % p; printf("%d\n",ans); &#125; if(s == 3) &#123; x = read(); z = read(); change(root,1,n,seg[x],seg[x] + siz[x] - 1,z); &#125; if(s == 4) &#123; x = read(); ans = query(root,1,n,seg[x],seg[x] + siz[x] - 1) % p; printf("%d\n",ans); &#125; &#125; return 0;&#125; 树状数组他死了 ST表倍增做法：预处理出f[i][j]表示从i开始，连续2^j个中的最小值 对比线段树：需要区间可合并 树状数组：需要区间可合并，并满足区间减法，不支持区间修改（min,max不满足区间减法） ST算法：需要区间可合并，不支持修改 线段树的要求最少，但代码最多 线段树适用范围最广，但速度最慢 图论有向无环图&amp;拓扑排序 不存在环的有向图被称为有向无环图（ Directed Acyclic Graph） 在有向无环图上，我们可以对节点进行排序，生成一个线性序列，使得：如果节点i在该有向无环图上可以沿着有向边到达节点j，那么节点i在线性序列中的位置一定在节点j之前生成线性序列的过程被称为拓扑排序 有向图 G 可以进行拓扑排序 等价于 有向图G是有向无环图 拓扑排序的简单应用：给出有向无环图G和一个点S，求S到G上其它所有点的路径的方案数 例题 P1347排序 https://www.luogu.org/problemnew/show/P2047https://www.luogu.org/problemnew/show/P2966 缩点强联通分量 强连通的定义：有向图 G 强连通是指，G 中任意两个结点连通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图 强连通分量+缩点+DGA上的动态规划是解决一系列有向图问题通用方法 tarjan 如果结点u是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以u为根的子树中。u被称为这个强连通分量的根。这一点我们可以用反证法证明，即如果一个和u在同一个强联通分量中的点不在以遇到的第一个节点u的子树中，那么它一定比u先被搜索到。 code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//https://www.luogu.org/problemnew/show/P3387#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int read()&#123; int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - 48; ch = getchar();&#125; return x * f;&#125;int cnt,cn,n,sc,p[100005],sz[100005],dfncnt,m,scc[100005],sta[100005],dfn[100005],low[100005],dfcnt,s[100005],tp,d[100005],h[100005],di[100005];struct EDGE&#123; int from,to,next;&#125;edge[500005],e[500005];void add(int x,int y)&#123; e[++cnt].from = x; e[cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void tarjan(int u)&#123; low[u] = dfn[u] = ++dfncnt,s[++tp] = u;// cout &lt;&lt; s[tp] &lt;&lt; " stp" &lt;&lt; endl; for(int i = d[u]; i; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v]) tarjan(v),low[u] = min(low[u],low[v]); else if(!scc[v]) low[u] = min(low[u],dfn[v]); &#125; if(dfn[u] == low[u])&#123; while(s[tp] != u) &#123; p[u] += p[s[tp]],scc[s[tp]] = u,sz[u] ++,--tp; &#125; scc[s[tp]] = u,sz[u] ++, --tp; &#125;&#125;int dist[100005];int topo()&#123; queue&lt;int&gt; que; int tot = 0; for(int i = 1; i &lt;= n; i++) if(scc[i] == i &amp;&amp; !di[i])&#123; que.push(i); dist[i] = p[i]; &#125; while(!que.empty())&#123; int k = que.front(); que.pop(); for(int i = h[k]; i; i = edge[i].next)&#123; int v = edge[i].to; dist[v] = max(dist[v],dist[k] + p[v]); di[v] --; if(di[v] == 0) que.push(v); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = max(ans,dist[i]); return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d",&amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y); &#125; for(int i = 1; i &lt;= n; i++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= m; i++)&#123; int x = scc[e[i].from],y = scc[e[i].to]; if(x != y)&#123; edge[++cn].next = h[x]; edge[cn].to = y; edge[cn].from = x; h[x] = cn; di[y] ++; &#125; &#125; printf("%d\n",topo()); return 0;&#125; Kosaraju算法 另一个比tarjan更好理解的求强联通分量的算法。 Kosaraju 算法依靠两次简单的 DFS 实现。 第一次 DFS，选取任意顶点作为起点，遍历所有为访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。 第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。 两次 DFS 结束后，强连通分量就找出来了 证明： 如果点A在连正向边时可以到达点B，点A在连反向边时也能到达点B，那么我们就可以判断，点A和点B是可以互相到达的。 code： 1234567891011121314151617181920212223242526272829void positive_dfs(int pos)&#123; DFN++; vis[pos]=1; for(int i=pre[1][pos];i;i=E[1][i].next) if(!vis[E[1][i].to]) positive_dfs(E[1][i].to); stack[N*2+1-(++DFN)]=pos;&#125;void negative_dfs(int pos)&#123; dye[pos]=CN; vis[pos]=0; size[dye[pos]]++; for(int i=pre[2][pos];i;i=E[2][i].next) if(vis[E[2][i].to]) negative_dfs(E[2][i].to);&#125;int main()&#123; ...... for(int i=1;i&lt;=N;i++) if(!vis[i]) positive_dfs(i); for(int i=1;i&lt;=N*2;i++) if(stack[i]&amp;&amp;vis[stack[i]])&#123; CN++; negative_dfs(stack[i]); &#125; ...... &#125; 推荐习题：https://www.luogu.org/problemnew/show/P1262 二分图定义&amp;性质 节点由两个集合组成，且两个集合内部没有边的无向图 重要性质：二分图不包括奇环。可用来做二分图的判定匈牙利算法求最大匹配每次寻找增广路径，都可以使得匹配数+1因此，不断递归寻找可能存在的增广路径，就可以得到二分图的最大匹配 如图，这就是一条增广路，粗边为选中的边。我们可以发现，对于一条增广路，如果我们删掉选中的边，加入未选的边，边数（匹配数）就会加1。 查分约束差分约束系统：由N个变量X_1, X_2, X_3 …. X_N和M个未知条件组成的N元一次不等式组，其中，每个条件都形如X_i &lt;= X_j + c_k我们的问题是：给出一组满足所有条件的解，否则判断出无解 注意到，X_i &lt;= X_j + c_k 与单源最短路中的三角不等式很相似，建立N个节点对应N个变量。对于每组条件，从 j 向i连一条边。同时虚构0号节点并向每一个节点连一条边，如果存在负环则无解。否则有解。 最近公共祖先考虑到一步一步跳太慢，我们考虑有没有快一点的跳法设fa[i][j] 表示节点i 的第2^j 个祖先是谁，fa[x][i] 可以预处理得到 考虑如何对朴素算法进行优化：1。 调整到同一高度2。 一起同时往上跳 略微占空间，并不是最优的LCA算法 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,m,s,x,y,cnt,d[1000005],f[500005][50],dp[500005];struct edge&#123; int to,next;&#125;e[1000005];void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void dfs(int u,int fa)&#123; dp[u] = dp[fa] + 1; f[u][0] = fa; for(int i = 1; i &lt;= 23; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = d[u]; i; i = e[i].next) &#123; if(e[i].to == fa) continue; dfs(e[i].to,u); &#125;&#125;int lca(int a,int b)&#123; if(dp[a] &gt; dp[b]) swap(a,b); int dis = dp[b] - dp[a]; for(int i = 22; i &gt;= 0; i--) &#123; int d = 1 &lt;&lt; i; if(d &lt;= dis) &#123; dis -= d; b = f[b][i]; &#125; &#125; if(a == b) return a; for(int i = 22; i &gt;= 0; i--) &#123; if(f[a][i] == f[b][i]) continue ; a = f[a][i]; b = f[b][i]; &#125; return f[a][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d",&amp;x,&amp;y); add(x,y); add(y,x); &#125; dfs(s,0); for(int i = 1; i &lt;= m; i ++) &#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",lca(x,y)); &#125; return 0;&#125; 贪心基本思想贪心是一种解题策略，更多是一种解题思想 使用贪心方法需要注意局部最优与全局最优的关系（用于区分贪心和动态规划），选择当前状态的局部最优并不一定能推导出问题的全局最优 利用贪心策略解题，需要解决两个问题：该题是否适合于用贪心策略求解。如何选择贪心标准，以得到问题的最优解 。 贪心问题的特点可以通过局部的贪心选择来达到问题的全局最优解，运用贪心策略解题，一般来说需要一步步的进行多次的贪心选择。在经过一次贪心选择后，原问题将变成一个相似的，但规模更小的问题，之后的每一步都是当前看似最佳的选择，且每一个选择都仅做一次。 原问题的最优解包含子问题的最优解，即具有最优子结构的性质，但并不是所有具有最优子结构的问题都可以用贪心策略求解。 分治思想分治分治，分而治之，分治算法就是将一个大问题划分为几个更小规模的形式相同的子问题并加以解决，通过解决子问题最后解决总问题。分治算法在OI中的运用主要在两个方面 二分查找、三分查找、二分答案 直接考察分治 二分答案常见于最小值最大或者最大值最小问题（基本上可以把这看做二分答案的标志）要求： 如果答案确定，我们能够快速判断答案是否合法 答案具有可二分性，即如果答案为i是可行的，答案为i+1即可行作用牺牲log(n)的复杂度，把求最优化问题变成了一个判断是否可行的问题，有时候能够简化问题。关键在于转化后的问题更好求解。 三分三分的难度要略低于二分(因为扩展出来的形式少)三分的用处在于求一个单峰函数的最值单峰函数，例如： code: 动态规划一维线性DP 比较常见的一种动态规划问题，特点是状态只有一维 例题： 但是时间复杂度是$O(n^2)$。 优化： 记录f[x]为当前时刻dp值为x的所有元素中高度最高的一个，用单调栈去优化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define INF 0x7fffffff using namespace std;int n,a[100005],sta[100005],t;void two_fen(int k)&#123; int l = 1, r = t, mid; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(sta[mid] &gt;= k) l = mid + 1; else r = mid - 1; &#125; sta[l] = k;&#125;void work()&#123; sta[0] = INF; t = 0; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt;= sta[t]) sta[++t] = a[i]; else two_fen(a[i]); &#125; //for(int i = 1; i &lt;= t; i++) cout &lt;&lt; sta[i] &lt;&lt; " ";cout &lt;&lt;endl; printf("%d\n",t);&#125;void count()&#123; memset(sta,0,sizeof(sta)); int j,place,x; t = 0; for(int i = 1; i &lt;= n; i++) &#123; place = 0; x = INF; for(int j = 1; j &lt;= t; j++) if(sta[j] &gt;= a[i] &amp;&amp; (sta[j] &lt; sta[place] || place == 0)) place = j; if(place == 0) sta[++t] = a[i]; else sta[place] = a[i]; &#125; printf("%d\n",t);&#125;int main()&#123; while(cin &gt;&gt; a[++n]); n --; work(); count(); return 0; &#125; 设d[i]为长度为n的错排的种类数，考虑构造一个错排序列。 $d[1] = 0$ $d[2] = 1$ $d[n]=(d[n-1] + d[n-2])*(n-1) (n &gt;= 3)$ $f[n] = f[n-1] + f[n-2]*2$ 考虑这样几种情况： 运一个人：a[n] ： $t=a[1]+a[n]$ 但这样不是最优的 若还剩a[n]和a[n-1]，则一个一个运： $t=a[1]+a[n-1]+a[1]+a[n]$ 但如果让a[n]和a[n-1]一起走，则： $t=a[1]+a[n]+a[2]+a[2]$ 所以我们有两种方案： 第一种 让过河时间最少的人过来送手电筒，然后带着你一起过河。 第二种 让过河时间最少的人过来送手电筒，然后你带着n-1号一起过河，此时手电筒在对岸，接着让过河时间第二少的人过来送手电筒，带着过河时间最少的人一起过河。 所以我们建立一个dp[i]来记录前i个人过河的最短时间。那么转换方程为$$dp[i] = min(p[i - 1] + a[0] + a[i], dp[i -2] + a[0] + a[i] + 2 * a[1]);$$ 背包问题 严格来说，背包问题并不是一个单独的问题，他是一系列比较类似的问题的总称 请注意，并非所有的背包问题都是动态规划问题 0-1背包 有N件物品和一个容量为V的背包。第i件物品的价格（即体积，下同）是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 对于一个物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时所得价值为：$f[i-1][v-c[i]]+w[i] $状态转移方程为：$f[i][v] = max(f[i-1][v], f[i-1][v-w[i]]+c[i])$ 最终的答案是 $Max(f[N][j] for\ j \ in [0,maxV])$ code: 1234int f[100005];for(int i = 1; i &lt;= n; i++) for(int j = v; j &gt;= w[i]; j--) f[i][j] = max(f[i][j],f[i][j - w[i]] + v[i]); 完全背包 N件物品和一个容量为V的背包。第i种物品的价格（即体积，下同）是w[i]，价值是c[i]，每种物品有无限多个。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 完全背包和01背包十分相像， 区别就是完全背包物品有无限件。由之前的选或者不选转变成了选或者不选，选几件。 用f[i][j]表示前i种背包装入容量为j的背包中所可以获得的最大价值 对于一种物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时，我们需要枚举放进去多少件，设为K，所得价值为：$f[i-1][v-Kc[i]]+Kw[i] $状态转移方程为：$f[i][v] = max(f[i-1][v-Kw[i]]+Kc[i]) 0&lt;=K&lt;=v/w[i]$ 最终的答案是 $Max(f[N][j] for \ j \ in [0,maxV])$ code: 123for(int i = 1; i &lt;= n; i++) for(int j = w[i]; j &lt;= v; j++) f[i][j] = max(f[i][j],f[i][j - w[i]] + v[i]); 多重背包 有N件物品和一个容量为V的背包。第i种物品的价格（即体积，下同）是w[i]，价值是c[i]，第i种物品最多有n[i]件可用。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。用f[i][j]表示前i种背包装入容量为j的背包中所可以获得的最大价值 对于一种物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时，我们需要枚举放进去多少件，设为K，所得价值为：$f[i-1][v-Kc[i]]+Kw[i]$状态转移方程为：$f[i][v] = max(f[i-1][v-Kw[i]]+Kc[i]) 0&lt;=K&lt;=v/w[i]，K&lt;= n[i]$ 最终的答案是 $Max(f[N][j] for \ j \ in [0,maxV])$ 那么，这样做的时间复杂度是多少呢？ $O(nW\sum k_i)$ 轻松TLE没商量。 所以我们要对此进行二进制分解优化，处理后我们可以把多重背包转化成 0-1 背包模型来求解。 为了表述方便，我们用$A_{i,j}$表示第$i$种物品拆分出的第$j$个物品。 我们令$A_{i,j}$ 表示由$2^j$的单个物品组合成的一个更大的物品。如果$k_i+1$不是2的整数次幂，就需要再添加一个物品，该物品由二进制分解后剩余的物品组成。 举个例子： $6=1+2+3$ $8=1+2+4+1$ $18=1+2+4+8+3$ $31=1+2+4+8+16$ 显然，通过上述拆分方式，可以表示任意 $\leq k$个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。 时间复杂度$O(nW\sum log \ k_i)$ code: 12345678910111213index = 0;for(int i = 1; i &lt;= m; i++) &#123; int c = 1, p, h, k; cin &gt;&gt; p &gt;&gt; h &gt;&gt; k; while(k - c &gt; 0) &#123; k -= c; list[++index].w = c * p; list[index].v = c * h; c *= 2; &#125; list[++index].w = p * k; list[index].v = h * k;&#125; 分组背包 有N件物品和一个容量为V的背包。第i件物品的价格（即体积，下同）是w[i]，价值是c[i]。这N个物品分成了若干个组，每个组里面的商品不可以同时选择。 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 code: 12345678910for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=A[i];j++)&#123; for(int k=0;k&lt;=V;k++)&#123; dp[i][k] = max(dp[i][k], dp[i-1][k]); if(k&gt;=v[i][j])&#123; dp[i][k] = max(dp[i][k], dp[i-1][k-v[i][j]]+c[i][j]); &#125; &#125; &#125; &#125; 树形DP这个地方是真的听懵了……以后再填坑吧…… 例题1： 树上的动态规划如何写状态函数，怎么转移？ 一般来说，绝大多数树上的一个节点i的状态函数都是对于以该点为根的子树的状态的概括。 好处：边界条件清晰（叶节点），无后效性，子树内部的具体情况与外界无关 以本题为例子： 总活跃指数最大（整棵树的活跃指数最大） —- 子树的活跃指数最大是多少？ code: 基环树 思路：先找到环，环以外的部分正常的树dp做，然后考虑断环 推荐习题 https://www.luogu.org/problemnew/show/P2607 状压DP code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - 48; ch = getchar();&#125; return x * f;&#125;int n,cnt,kk,zt[2000],l[2000];long long ans,f[10][20000][100];void dfs(int j,int p,int s)&#123; if(p &gt;= n) &#123; zt[++cnt] = j; l[cnt] = s; return ; &#125; dfs(j,p + 1,s); dfs(j + (1 &lt;&lt; p),p + 2,s + 1);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;kk); dfs(0,0,0); for(int i = 1;i &lt;= cnt; i++) f[1][i][l[i]] = 1; for(int i = 2;i &lt;= n; i++) for(int j = 1; j &lt;= cnt; j++) for(int k = 1; k &lt;= cnt; k++) &#123; if(zt[j] &amp; zt[k]) continue; if((zt[j] &lt;&lt; 1) &amp; zt[k]) continue; if(zt[j] &amp; (zt[k] &lt;&lt; 1)) continue; for(int s = kk; s &gt;= l[j]; s--) f[i][j][s] += f[i - 1][k][s - l[j]]; &#125; for(int i = 1; i &lt;= cnt; i++) ans += f[n][i][kk]; printf("%lld\n",ans); return 0;&#125; 数位DP问题模型：给定两个很大的正整数 a,b, 求在[a,b]内有多少数字满足性质 xxxxx 我们用f数组记录第i位以j开头的方案总数，然后累加就好了，这里就不详细说了（因为我真的不会……）。code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;long long F[12][10];int my_abs(int x)&#123;return x&lt;0?-x:x;&#125;long long GetAns(long long x)&#123; if(x==0)return 1; long long ans = 0; long long now=0; int tmp[12],ct=0; long long t = x; while(t&gt;0)&#123;ct+=1;t=t/10;&#125; t = x; for(int i=1;i&lt;=ct;i++)&#123; tmp[i] = t%10; t=t/10; &#125; now=1; for(int i=1;i&lt;ct;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; ans += F[i][j]; &#125; &#125; for(int i=ct;i&gt;=1;i--)&#123; if(ct==i)&#123; for(int j=1;j&lt;tmp[i];j++)&#123; ans = ans + F[i][j]; &#125; &#125; else &#123; for(int j=0;j&lt;tmp[i];j++)&#123; if(my_abs(j-tmp[i+1])&lt;2)&#123; continue; &#125; ans = ans + F[i][j]; &#125; if(my_abs(tmp[i]-tmp[i+1])&lt;2)&#123; break; &#125; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0;i&lt;=9;i++)F[1][i] = 1; for(int i=2;i&lt;12;i++)&#123; for(int j=0;j&lt;=9;j++)&#123; F[i][j]=0; for(int k=0;k&lt;=9;k++)&#123; if(my_abs(j-k)&lt;2)&#123; continue; &#125; F[i][j] += F[i-1][k]; &#125; &#125; &#125; long long L, R; cin &gt;&gt; L&gt;&gt;R; cout&lt;&lt;GetAns(R+1)-GetAns(L)&lt;&lt;endl; return 0;&#125; 对拍想要对拍，我们需要这样几个部分： 想要判断对错的代码 暴力代码 一个数据生成器 一个用来对拍的程序 我们以这个题为例 不确认对错的代码： 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a.in&quot;, &quot;r&quot;, stdin); freopen(&quot;a.out&quot;, &quot;w&quot;, stdout); long long a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a * b - a - b &lt;&lt; endl; return 0;&#125; 暴力代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;using namespace std;bool ok(int n, int a, int b)&#123; for (int x = n/a; x &gt;= 0; -- x) if ((n - a * x) % b == 0) return true; return false;&#125;int main()&#123; freopen("a.in", "r", stdin); freopen("a_std.out", "w", stdout); int a, b; scanf("%d%d", &amp;a, &amp;b); for (int i = 1000000; i &gt;= 0; -- i) if (! ok(i, a, b)) &#123; printf("%d\n", i); break; &#125; return 0;&#125; 数据生成器： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;using namespace std;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a%b);&#125;int main()&#123; srand((int)time(0)); freopen(&quot;a.in&quot;, &quot;w&quot;, stdout); int a, b; do &#123; a = rand() % 50 + 2; b = rand() % 50 + 2; &#125; while (gcd(a, b) &gt; 1); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return 0;&#125; 对拍程序： 12345678@echo off:1genabrute_forcefc a.out a_std.outif %errorlevel% == 0 goto pause]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>分治</tag>
        <tag>动态规划</tag>
        <tag>对拍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash-学习]]></title>
    <url>%2F2019%2F08%2F02%2FHash-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基本概念Hash，一般翻译做“散列”，也有直接音译为“哈希”的。那么哈希函数的是什么样的？大概就是 value = hash(key)，我们希望key和value之间是唯一的映射关系。 大家使用的最多的就是哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做哈希函数或散列函数。 实际中的Hash主要有两种应用：加密和压缩。在加密方面，Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值，最广泛应用的Hash算法有MD4、MD5、SHA1。在压缩方面，Hash哈希是指把一个大范围映射到一个小范围，往往是为了节省空间，使得数据容易保存。 当然了，在我们做题的过程中，使用到的hash的方法都是十分简单的。 Hash的特点 主要原理就是把大范围映射到小范围，因此输入范围必须和小范围相当或者比它更小，否则增加冲突。 Hash函数逼近单向函数，所以可以用来对数据进行加密。（单项函数：如果某个函数在给定输入的时候，很容易计算出其结果来；而当给定结果的时候，很难计算出输入来） 不同的应用对Hash函数有着不同的要求：用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。 具体实现Hash的方法非常多，有用加法的，有用乘法的，有用位运算的，还有混合的。这里，为了尽可能减小冲突的可能性，我们选择用混合运算去Hash。 Hash的具体思路就是把一串字符计算后形成一个数字。我们直接来看一段Hash的代码来理解吧： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define ll long long #define INF 0x7fffffff using namespace std; int hash(char s[]){ int h = 0, l = strlen(s), k; for(register int i = 0; i &lt; l; i++) { k = s[i]; h = (h * 31 + k &lt;&lt; 1) % 23456789; } return h;} char s[1000]; int main(){ while(1) { cin &gt;&gt;s; cout &lt;&lt;hash(s) &lt;&lt; endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[做题计划]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[一、基础算法知识点 枚举 模拟 贪心 分治例题 IOI 2013 Robert 斗地主 国王游戏（2013 年 NOIP 提高组） 猪国杀 Balanced Lineup（POJ 3264） KD 之死（BZOJ 1555） Kieszonkowe（BZOJ 4291） Well （BZOJ 2792） 二、 基本数论算法知识点 高精度、进制转换 快速幂、取模运算 排列组合数，进制转换， Lucas 定理 容斥原理 gcd 算法、 exgcd 算法以及裴蜀定理 逆元、解同余方程组（中国剩余定理） 线性筛求素数 欧拉函数、欧拉定理、费马小定理、线性筛求欧拉函数（扩展到各类积性函数） 卡塔兰数、斯特林数、 伯努利数 矩阵相关知识、行列式 高斯消元求线性基学习重点 组合数的各种计算方式（杨辉三角， Lucas 定理，计算 n!的逆元， Lucas 的扩展） 对于数据范围要保持敏感，一方面是高精度和 long long 取模的使用，另一方面是将公式变为带取模公式时的细节。 利用中国剩余定理解决模数不是素数时的同余方程 理解线性筛求积性函数的过程 利用矩阵快速幂求递推函数（常用于优化 DP） 异或高斯消元与高斯消元求行列式及矩阵逆例题 基因变异（CODEVS 3194） 同余方程（NOIP2012 提高组）（CODEVS 1200） 青蛙的约会（POJ1061） 礼物（CODEVS 1321） 麦森数（CODEVS 1087） 统计公共子序列个数（CODEVS 1778） Xn 数列（CODEVS1281） 组合数问题（BZOJ 4870） 树（BZOJ 2466） 三、数据结构知识点 对并查集的两种优化方式（按秩合并、路径压缩）都理解和掌握 如何利用并查集维护额外信息，并查集的扩展问题 线段树的双标记下传问题 树状数组与差分的结合——树状数组扩展 二维线段树和二维树状数组 权值线段树和同态加点的线段树 线段树的启发式合并 树上倍增 LCA、树上倍增维护链上数据 多项式加速字串 hash 求值 双 hash、 hash 挂链的实现例题 . NOIP 2012 借教室 NOIP 2010 关押罪犯（CODEVS 1069） NOI2011 食物链（CODEVS 1074） NOI2002 银河英雄传说（CODEVS 1540） 苹果树（CODEVS 1228） 等差子序列（CODEVS 1283） NOIP2017 列队 四、图论知识点 欧拉回路 最小生成树、次小生成树 最短路算法、次短路算法、 K 短路算法 dijkstra 的堆优化， spfa 的 SLF、 LLL 优化 差分约束问题 树上倍增 外向树上的 DP 强连通分量、 有向图的拓扑排序、以及有向无环图的 DP 过程 无向图割点和桥的求法 经典的 2-sat 问题和婚姻匹配问题 二分图匹配问题的多个转化（最大团、最大独立集等）例题 Car 的旅行线路（NOIP2001）（CODEVS 1041） BZOJ 1977 次小生成树 Poj 1201 Intervals Poj 3621 Sightseeing Cows 货车运输（NOIP 2013） 骑士（BZOJ 1040） BZOJ 1512 BZOJ 1093 最大半联通子图 BZOJ 2199 奶牛议会 NOIP2016 天天爱跑步 五、动态规划知识点 + 例题 序列类： 1. 最长上升子序列； 2. 最长公共子序列； 背包类： 1. 0-1 背包问题； 2. 完全背包问题； 区间类： 1. 石子归并类问题；（NOIP2006 能量项链） 其他： 1. 数字三角形问题； 2. 有向无环图最短路问题； 树形 DP：思路和序列类或背包类类似，只是结构从序列变成了树（CODEVS1380 没有上司的舞会） 棋盘 DP: 同上，只是从一维的序列变成了一个二维的棋盘（NOIP2007 矩阵取数游戏） 记忆化搜索： dfs 的优化，通过防止 dfs 的重复计算来加快速度，本质就是 DP（poj1088 滑雪） 基本优化： 1. 决策单调性优化； 2. 四边形不等式优化； 优化：单调队列优化（BZOJ 1855、 POJ 1821、 POJ 3926） 状压 DP：状态划分时状态本身是一串 0 ~ (k-1) 的数字，代表当前第 i 个节点的状态，故可以用一个 N 位的 k 进制数表示，通过位运算来进行状态转移，故叫状压 DP（例题： poj 3254、 BZOJ 4057、 BZOJ 3195） 数位 DP：数位 DP 是一种计数形式的 DP，其状态是每一个数位，一般用于求一个区间内满足条件的数的个数，通过枚举每一位放的数来进行状态转移（例题： HDU 2089、BZOJ 1026、 HDU 4734、 POJ 3252）]]></content>
  </entry>
  <entry>
    <title><![CDATA[关押罪犯-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 qxy做的第一道种类并查集的题目种类并查集不会的戳这里 这道题基本上就是一个种类并查集的板子题，于是我们直接附一下代码好了： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,a,b,v,q,f[40005]; struct person{ int x,y,w;}p[100005]; int mysort(person x,person y){ return x.w &gt; y.w;} int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) { f[i] = i; f[i + n] = i + n; } for(register int i = 1; i &lt;= m; i++) scanf(“%d%d%d”,&amp;p[i].x,&amp;p[i].y,&amp;p[i].w); sort(p + 1, p + m + 1, mysort); for(register int i = 1; i &lt;= m; i++) { a = p[i].x; b = p[i].y; v = p[i].w; if(find(a) == find(b) || find(a + n) == find(b + n)) { cout &lt;&lt; p[i].w; return 0; } f[find(a)] = f[find(b + n)]; f[find(b)] = f[find(a + n)]; } printf(“0”); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[冻结-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%BB%E7%BB%93-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 又是一道分层图最短路的裸题分层图最短路不会的戳这里 这道题之需要把分层图最短路的方程稍微改一下就可以了。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 2147483647 using namespace std; struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}}; priority_queue&lt;node&gt; que; long long n,m,k,s,t,d[50005],cnt,D[50005][60],v[50005][60]; struct Edge{ int to,next,x;}edge[2000005]; void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;} int main(){ int x,y,a; scanf(“%lld%lld%lld”,&amp;n,&amp;m,&amp;k); s = 1; t = n; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;a); add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &amp;gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &amp;lt; k &amp;amp;&amp;amp; D[too][level + 1] &amp;gt; D[kk][level] + edge[i].x / 2) { D[too][level + 1] = D[kk][level] + edge[i].x / 2; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &amp;lt;= k; i++) ans = min(ans,D[t][i]); printf(&quot;%lld\n&quot;,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[化学实验视频]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%8C%96%E5%AD%A6%E5%AE%9E%E9%AA%8C%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[实验11粗盐提纯实验12配制溶液实验13制取氧气实验14二氧化碳制取及性质实验15金属与酸盐溶液的反应实验16中和反应实验十七 &amp;&amp; 实验十八]]></content>
  </entry>
  <entry>
    <title><![CDATA[回文分割-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 思路我们可以对读入的字符串s任意排序，但是实际上我们并没有必要对s进行排序——aabbaa和baaaab其实对于这道题来讲是一样的。我们可以发现，对于数量为偶数的字母，我们将其中的偶数个分别添加到某个回文串的两侧，这样就可以得到一个更长的回文串。而且，每个回文串中至多有一个字母在本回文串的个数为1。这就意味着，若数量为奇数的字母有n个，则我们至少需要把s分成n个回文串。因此，奇数影响着回文串的个数，偶数影响回文串的长度。所以，我们只需要记录每一个字母的出现次数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}char s[1000005]; int t[100],j,o;int main(){ cin &gt;&gt; s; int l = strlen(s); for(int i = 0; i &lt; l; i++) t[s[i] - 'a' + 1] ++; for(int i = 1; i &lt;= 26; i++) { j = j + t[i] % 2; o = o + t[i] / 2; } int ans; if(j) ans = o / j * 2 + 1; else ans = o * 2; cout &lt;&lt; ans &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[寻找最优美做题曲线]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BC%98%E7%BE%8E%E5%81%9A%E9%A2%98%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[查看题目戳这里 一道最长上升子序列的裸题由题目描述可以看出，我们选择的日期中每天做题数量一定是递增的。这样，我们就能很轻易地想到用最长上升子序列去完成这道题。在这里，由于数据范围较大，我们需要用nlogn的算法去完成这道题。 那么，怎么去处理这必须做题的k天呢？由于这k天做题数量一定是最长上升子序列的一部分，这样我们就可以发现有某些天是一定不能选的。当我们把这些一定不能选的日期删掉后就会发现，只要我们按照正常的算法去求最长上升子序列，那么这k天一定是包含在里面的。（想一想，为什么）至于判断是否有最长上升子序列，只需要判读这必选的k天是否单调上升即可。附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int n,k,cnt,t,a[500005],c[250005],sta[500005]; int mysort(int a,int b) {return a &lt; b;} int judge(){ sort(c + 1, c + k + 1, mysort); for(int i = 2; i &lt;= k; i++) if(a[c[i]] &lt;= a[c[i - 1]]) { printf(“impossible”); return 1; } return 0;} void clean(){ for(int i = 1; i &lt; c[1]; i++) if(a[i] &gt;= a[c[1]]) a[i] = -1; for(int i = 1; i &lt; k; i++) for(int j = c[i] + 1; j &lt;= c[i + 1] - 1; j++) if(a[j] &lt;= a[c[i]] || a[j] &gt;= a[c[i + 1]]) a[j] = -1; for(int i = c[k] + 1; i &lt;= n; i++) if(a[i] &lt;= a[c[k]]) a[i] = -1; for(int i = 1; i &lt;= n; i++) if(a[i] != -1) a[++cnt] = a[i];} void two_fen(int k){ int l = 1,r = t,mid; while(l &lt;= r) { mid = (l + r) &gt;&gt; 1; if(sta[mid] &lt; k) l = mid + 1; else r = mid - 1; } sta[l] = k;} void work(){ sta[0] = -1008611; for(int i = 1; i &lt;= cnt; i++) { if(a[i] &gt; sta[t]) sta[++t] = a[i]; else two_fen(a[i]); } printf(“%d\n”,t);} int main(){ scanf(“%d%d”,&amp;n,&amp;k); for(int i = 1; i &lt;= k; i++) scanf(“%d”,&amp;c[i]); for(int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); if(judge()) return 0; clean(); work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[导弹拦截-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道经典dp题……它有两问，第一问是一个裸的最长不上升子序列，不会的戳这里。 至于第二问，非常简单，做法也有很多，像最长上升子序列、贪心、模拟…… 附一下代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #define INF 0x7fffffff using namespace std; int n,a[100005],sta[100005],t; void two_fen(int k){ int l = 1, r = t, mid; while(l &lt;= r) { mid = (l + r) &gt;&gt; 1; if(sta[mid] &gt;= k) l = mid + 1; else r = mid - 1; } sta[l] = k;} void work(){ sta[0] = INF; t = 0; for(int i = 1; i &lt;= n; i++) { if(a[i] &lt;= sta[t]) sta[++t] = a[i]; else two_fen(a[i]); } //for(int i = 1; i &lt;= t; i++) cout &lt;&lt; sta[i] &lt;&lt; “ “;cout &lt;&lt;endl; printf(“%d\n”,t);} void count(){ memset(sta,0,sizeof(sta)); int j,place,x; t = 0; for(int i = 1; i &lt;= n; i++) { place = 0; x = INF; for(int j = 1; j &lt;= t; j++) if(sta[j] &gt;= a[i] &amp;&amp; (sta[j] &lt; sta[place] || place == 0)) place = j; if(place == 0) sta[++t] = a[i]; else sta[place] = a[i]; } printf(“%d\n”,t);} int main(){ while(cin &gt;&gt; a[++n]); n –; work(); count(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[局域网-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%B1%80%E5%9F%9F%E7%BD%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看题目戳这里 一道最小生成树的裸题，这里我们用kruskal来做kruskal 是一种求最小生成树的算法，时间复杂度为O(nlogn)它的算法思路是这样的：我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,q[6000];struct lalala{ int x,y,z,save;}a[210000];int mysort(lalala a,lalala b){ return a.z &lt; b.z;}int work(int x,int y){ while(q[q[x]] != q[x]) q[x] = q[q[x]]; while(q[q[y]] != q[y]) q[y] = q[q[y]]; if(q[x] == q[y]) return 1; else { q[q[y]] = q[x]; return 0; }}int main(){ long long ans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) q[i]=i; for(int i=1; i&lt;=m; i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z; ans += a[i].z; } sort(a+1,a+m+1,mysort); for(int i=1;i&lt;=m;i++) { if(!work(a[i].x,a[i].y)) ans -= a[i].z; } cout &lt;&lt; ans; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[无序字母对-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看题目请戳这里 又一道欧拉回路的裸题把字母hash一下，然后跑一个欧拉回路就可以轻松搞定。 不会欧拉回路的戳这里。 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,x,y,tj,begin = INF,t,map[1000][1000],d[1000],sta[1000]; char s[2]; int getint(char c){ if(c &lt; ‘a’) return c - ‘A’ + 1; return c - ‘a’ + 27;} char getcha(int c){ if(c &lt;= 26) return c + ‘A’ - 1; return c + ‘a’ - 27;} void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] = 0; map[i][k] = 0; dfs(i); } } sta[++t] = k;} int main(){ scanf(“%d”,&amp;m); for(register int i = 1; i &lt;= m; i++) { cin &gt;&gt; s; x = getint(s[0]); y = getint(s[1]); n = max(x,n); n = max(y,n); begin = min(begin,x); begin = min(begin,y); map[x][y] = 1; map[y][x] = 1; d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) if(d[i] % 2 == 1) tj ++; if(tj == 1 || tj &gt;2) { printf(“No Solution\n”); return 0; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } dfs(begin); int k = begin; for(register int i = t; i &gt;0; i–) cout &lt;&lt; getcha(sta[i]); cout &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字权重-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%95%B0%E5%AD%97%E6%9D%83%E9%87%8D-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题 一道非常简单的数论题为什么说它非常简单呢？可能大家刚开始看到那个式子会有点懵，但是如果你把求和函数展开就会发现，式子会变为 a[n] - a[n-1] + a[n-1] - a[n-2] + … +a[2] - a[1]然后你就会发现这个求和函数的值只与an与a1的值有关…… 于是这个题一下就简单很多了。那么，具体该怎么做呢？首先，既然这个式子的值与a[n]与a[1]的差有关，由于k的范围只能为 -9 ~ 8 ，我们完全可以打一张表出来（其实等表打出来了，规律也就一目了然了）。至于剩下的 n - 2 位，它们的值可以是 0 ~ 9 之间的任何一个数字。于是中间每多一位，就会使ans * 10。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; long long ksm(long long x,long long y,long long mod) //快速幂，不会的自己去百度{ long long ans = 1; while(y &gt; 0) { if(y &amp; 1) ans = (ans * x) % mod; x = (x * x) % mod; y = y &gt;&gt; 1; } return ans % mod;} int main(){ long long mod = 1000000007, n, k, ans; cin &gt;&gt; n &gt;&gt; k; long long a = 9 - abs(k); if(k &lt; 0) a++; if(k &gt;= 9 || k &lt; -9) //特判，k在此情况下方案数一定为0 { cout &lt;&lt;0&lt;&lt; endl; return 0; } cout &lt;&lt; (a * ksm(10, n - 2, mod)) % mod &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[星球大战-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 我没看过电影qwq…… 刚开始看到这个题，觉着可以用Floyd去做，时间复杂度为n^3…… 于是…… 我们还是用并查集好了当然了，如果我们在每次删去一个点后就跑一遍并查集去统计联通块的数量，那么一定会超时的。 所以，我们要用另一种方法…… 倒着做！然后，我们先把所有将被干掉的星球的状态都先记为死亡，然后一个个的复活并用所有与该点有关的边去更新联通块的数量。 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,cnt,k,x,y,f[400005],head[400005],kill[400005],live[400005],ans[400005]; struct Edge{ int to,next;}edge[400005]; void add(int a,int b){ edge[++cnt].to = b; edge[cnt].next = head[a]; head[a] = cnt;} int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);} void work(int x,int y){ if(find(x) != find(y)) f[find(x)] = f[find(y)];} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) f[i] = i; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d”,&amp;x,&amp;y); x ++; y ++; add(x,y); add(y,x); } scanf(“%d”,&amp;k); for(register int i = k; i &gt; 0; i–) { scanf(“%d”,&amp;kill[i]); kill[i] ++; live[kill[i]] = 1; } cnt = n; for(register int i = 1; i &lt;= n; i++) if(!live[i]) for(register int j = head[i]; j; j = edge[j].next) if(!live[edge[j].to]) if(find(i) != find(edge[j].to)) { cnt –; work(i,edge[j].to); } cnt = cnt - k; ans[1] = cnt; for(register int i = 1; i &lt;= k; i++) { live[kill[i]] = 0; cnt ++; for(register int j = head[kill[i]]; j; j = edge[j].next) if(!live[edge[j].to]) if(find(kill[i]) != find(edge[j].to)) { cnt –; work(kill[i],edge[j].to); } ans[i + 1] = cnt; } for(register int i = k + 1; i &gt; 0; i–) printf(“%d\n”,ans[i]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[晕牛-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%99%95%E7%89%9B-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 每错，这是一道拓扑排序的题。为什么这么说呢？因为拓扑排序的前提要求是进行排序的图必须是DAG。我们在看这道题的要求，就会发现，当你把所有双向边改成单向边以后，这个图就一定是一个DAG，否则一定无解。 呢么，我们该怎么进行拓扑排序呢？首先，对于给出的有向边，我们按照正常的拓扑排序的方式进行排序即可。 对于无向边，我们要双向连边，但是不更新入度。每当我们在拓扑排序是遍历到一条没有被处理过的双向边时，只需要把这条边的起点记录为当前正在遍历的节点即可。（想一想，为什么）· 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; struct Edge{ int from,to,next,del;}edge[2000005]; int t,a,b,n,p1,p2,head,tail,que[100001],d[100001],k[100001]; void add(int x,int y,int pd){ edge[++t].to = y; edge[t].from = x; edge[t].next = d[x]; d[x] = t; edge[t].del = pd;} int main(){ scanf(“%d%d%d”,&amp;n,&amp;p1,&amp;p2); for( int i = 1; i &lt;= p1; i++) { scanf(“%d%d”,&amp;a,&amp;b); add(a,b,0); k[b] ++; } if(t % 2 == 0) t++; for( int i = 1; i &lt;= n; i++) if(k[i] == 0) que[++tail] = i; for( int i = 1; i &lt;= p2; i++) { scanf(“%d%d”,&amp;a,&amp;b); add(a,b,1); add(b,a,1); } while(head &lt; tail) { head++; int u = que[head]; for( int i = d[u]; i; i = edge[i].next) { if(edge[i].del == 0) { k[edge[i].to] –; if(k[edge[i].to] == 0) que[++tail] = edge[i].to; } else if(edge[i].del == 1) edge[i^1].del = 2; } } for( int i = 1;i &lt;= t; i++) if(edge[i].del == 1) printf(“%d %d\n”,edge[i].from,edge[i].to); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[最接近的分数-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%88%86%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 emmmmm…… 感觉这道题就是一个暴力…… 首先，由于n和m的范围都很大，所以直接枚举n和m会超时，所以我们需要换一种思路，那就是之枚举一个。 因为我们要使x/y的值与a的值最接近，所以当x/y = a时，x = a * y，所以我们只需要枚举y的值即可。 由于实数转整数的时候比较迷，所以我们要分别向上和向下取整 ps：别忘了TOO MANY的特判 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define re register #define INF 0x7fffffff #define ll long long using namespace std; int read(){ int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;’9’ || ch &lt; ‘0’){if(ch == ‘-‘) f = -f; ch = getchar();} while(ch &gt;= ‘0’ &amp;&amp; ch &lt;= ‘9’){x = x * 10 + ch - ‘0’; ch = getchar();} return x * f;} int gcd(int a, int b){return a == 0 ? b : gcd(b % a, a);} int n,m,x,u,pd,g,oo; double a,k,Min = INF,j,te; int work1(int i){ k = a * i; u = k; k = u + 1; te = k / i; j = fabs((k / i) - a);} int work2(int i){ k = a * i; u = k; k = u; te = k / i; j = fabs((k / i) - a);} int main(){ m = read(); n = read(); cin &gt;&gt; a; for(re int i = 1; i &lt;= n; i++) { work1(i); if(j &amp;lt; Min &amp;amp;&amp;amp; u &amp;lt;= m) { Min = j; x = i; pd = 0; oo = te * x; } work2(i); if(j == Min &amp;amp;&amp;amp; u &amp;lt;= m) pd = 1; if(j &amp;lt; Min &amp;amp;&amp;amp; u &amp;lt;= m) { Min = j; x = i; pd = 0; oo = te * x; } } if(a &amp;lt; 0.5&amp;amp;&amp;amp; (m &amp;lt; 2 || n &amp;lt; 2)) { printf(&quot;TOO MANY\n&quot;); return 0; } double ans1 = a * x,ans2 = a * x + 1; int ans = ans1; ans2 = ans; if(fabs(ans2/x - a) &amp;gt; fabs((ans2 + 1)/x - a)) ans ++; g = gcd(x,ans); if(g ==0) g = 1; if(x == 0) { cout &amp;lt;&amp;lt;&quot;1/1&quot;&amp;lt;&amp;lt; endl; return 0; } printf(&quot;%d/%d\n&quot;,ans / g, x / g); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[灾后重建-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 这道题目考查的就是对Folyd的灵活运用因为这题是需要你去求多元最短路，所以用Dijkstra或SPFA的话，时间复杂度显然是不可以接收的。 当然了，如果你直接用Floyd的话，也是会超时的。所以这道题就需要我们掌握Floyd的原理，才可以解决掉。 那么，我们该怎么去做呢？我们会发现，这道题目每个村庄修好的时间是不一致的，根据Floyd的思想，对于每一个新的查询时间t，我们只需要用在第k天修好的村庄去更新其它村庄的最短路即可。 在更新的过程中，我们会发现我们枚举的i，j两个点可能是尚未修复的，但这并没有关系，因为安照我们的算法思路，未被修复的村庄是不会被拿来更新其它村庄的距离的，而对于这两个村庄，我们只需要在读入时特判一下即可。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #define INF 1000000000 using namespace std; int n,m,q,cnt,x,y,t,T,fi[300],head[300],map[300][300]; struct Edge{ int to,next,x;}edge[100005]; void floyd(int k){ for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) map[i][j] = min(map[i][j],map[i][k] + map[k][j]);} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) map[i][j] = INF; for(register int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;fi[i]); for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;t); x ++; y ++; //个人习惯存的点的边号为1n，而题目给出的是0n-1 map[x][y] = t; map[y][x] = t; } scanf(“%d”,&amp;q); T = 0; for(register int a = 1; a &lt;= q; a++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;t); x ++; y ++; while(t &gt;= fi[T + 1] &amp;&amp; T &lt; n) { T++; floyd(T); } if(fi[x] &gt; t || fi[y] &gt; t || map[x][y] == INF) { printf(“-1\n”); continue ; } printf(“%d\n”,map[x][y]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[物理实验视频]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%89%A9%E7%90%86%E5%AE%9E%E9%AA%8C%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[试题一：石块密度试题二：测盐水密度试题三：杠杆平衡试题四：浮力大小试题五：平面镜成像试题六：电流与电压的关系试题七：串并联电路试题八：测小灯泡的电功率试题九：观察水的沸腾试题十：凸透镜成像]]></content>
  </entry>
  <entry>
    <title><![CDATA[生物实验视频]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%94%9F%E7%89%A9%E5%AE%9E%E9%AA%8C%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[实验十九实验二十实验二十一实验二十二实验二十三实验二十四]]></content>
  </entry>
  <entry>
    <title><![CDATA[离散化-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[·什么是离散化？离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。 ·为什么要用、什么时候要用离散化呢？如果让你吧1000个1到1000的数放到桶里，那么非常简单，直接开一个大小为1000的数组，然后在里面统计就可以了。但是，如果吧这1000个数的大小改为1到1000000000呢？很显然，直接开一个大小为1000000000的数组去统计是不现实的，直接MLE。这时，我们就需要用到离散化了。（当然，这只是一个小例子） ·我们怎么去实现离散化呢？对于一个数组a，我们可以用另外一个数组去记录其中每个数的大小关系（如数字b在a中为第k大），这样就可以在新得到的数组中查询每个数的大小关系。这样，我们就达到了离散化的目的。而且，我们可以利用这个大小关系来得到之前原数组对应位置的数字。 ·具体该怎么用代码实现呢？为了实现离散化，我们需要用到unique和lower_bound这两个函数。 uniqueunique可以统计某数组中不同元素的个数，如我们想用cnt去记录长度为n的数组a中有几个不同的元素，则可以用到unique，代码为 cnt = unique(a + 1, a + n + 1) - a - 1lower_bound其实还有一个叫upper_bound的函数 lower_bound可以返回某个元素在某个数组中是第几大的。例如，如你想用ans去记录数字b在长度为n数组a中是第几大的，那么就可以通过lower_bound去实现，代码为 ans = lower_bound(a + 1, a + n + 1, b) - a;附一下完整代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,cnt,ans,a[1000],b[1000],x[1000];int mysort(int a,int b) {return a &lt; b;}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; //输入 for(int i = 1; i &lt;= n; i++) x[i] = a[i]; //用x记录a，方便后续操作 sort(x + 1, x + n + 1, mysort); //排序 对于统计来书可有可无，但方便去重和还原 cnt = unique(x + 1, x + n + 1) - x - 1; //统计x中不同颜色的个数 for(int i = 1; i &lt;= n; i++) b[i] = lower_bound(x + 1, x + n + 1, a[i]) - x; //统计每个元素在原数组的大小位置 cout &lt;&lt; "cnt = " &lt;&lt; cnt &lt;&lt; endl; //查看不同元素的个数 for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; " "; //查看离散化后的数组 cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; x[b[i]] &lt;&lt; " "; //还原数组a cout &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[糖果传递-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里怎么说呢，这道题貌似需要用式子来表示出每个小盆友的代价，才可以理解这道题的做法。对于每一个小盆友，他最终的糖果数是一定要等于平局数的。所以，我们用a表示小盆友原有的糖果，xn表示他给上一个小盆友的苹果数，x(n + 1)表示他的下一个小盆友给他的糖果数，则有： 对于第1个小朋友，A1-X1+X2=ave -&gt; X2=ave-A1+X1 = X1-C1(假设C1=A1-ave，下面类似） 对于第2个小朋友，A2-X2+X3=ave -&gt; X3=ave-A2+X2=2ave-A1-A2+X1=X1-C2 对于第3个小朋友，A3-X3+X4=ave -&gt; X4=ave-A3+X3=3ave-A1-A2-A3+X1=X1-C3 …… 对于第n个小朋友，An-Xn+X1=ave。 至于如何确定X1的值，我们去中位数即可。(不懂的可以看货仓选址问题）附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; ll n,a[1000005],ans,sum,p,s[1000005]; int main(){ scanf(“%lld”,&amp;n); for(register int i = 1; i &lt;= n; i++) { scanf(“%lld”,&amp;a[i]); sum += a[i]; } p = sum / n; for(register int i = 1; i &lt;= n; i++) a[i] -= p; for(register int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; sort(s + 1, s + n + 1); int t = s[(n + 1) &gt;&gt; 1]; for(register int i = 1; i &lt;= n; i++) ans += fabs(t - s[i]); printf(“%lld”,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[缺省源]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BC%BA%E7%9C%81%E6%BA%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int main(){ return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[菜肴制作-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道明目张胆的拓扑排序的题目首先，由于题目给出“某些菜肴必须在另一些菜肴之前制作”这一条件，所以这道题可以用拓扑去做。其次，根据题目给出的“最优的菜肴制作顺序”的定义，我们自然而然的想到题目是让我们求字典序最小的拓扑序。 然而，这样做事错误的。出题人可以轻松把你卡掉，比如样例的第三组数据，答案是1 5 2 4 3，但是如果你是求的字典序最小的拓扑序，那么你求出的结果将会是1 4 3 5 2。很显然，2的位置靠后了。 既然求最小的字典序行不通，那么我们是不是可以反过来想呢？由于题目要求你把小的数尽量往前放，所以答案不一定是最小的字典序。但是，把小的数尽量往前方，那么大的数自然会尽量往后，这样一来，如果把拓扑序反过来，那么字典序最大的反拓扑序就一定是最优解。于是，我们可以建一个返图去求字典序最大的拓扑序，最后再倒序输出。 tip：为了优化时间复杂度，我们可以用堆去进行拓扑排序。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 0x7fffffff using namespace std; priority_queue&lt;int&gt;que; int t,n,m,x,cnt,d[100005],k[100005],ans[100005]; struct Edge{ int to,next;}edge[100005]; struct node{ int x,y;}u[100005]; void add(int x,int y){ edge[++cnt].to = y; edge[cnt].next = d[x]; d[x] = cnt; k[y] ++;} int mysort(node a,node b) {return a.y &lt; b.y;} void clean(){ while(!que.empty()) que.pop();} void work(){ for(register int i = 1; i &lt;= n; i++) if(k[i] == 0) que.push(i); while(!que.empty()) { x = que.top(); ans[++cnt] = x; que.pop(); for(register int i = d[x]; edge[i].to != 0; i = edge[i].next) { k[edge[i].to] –; if(k[edge[i].to] == 0) que.push(edge[i].to); } }} int main(){ scanf(“%d”,&amp;t); for(register int a = 1; a &lt;= t; a++) { cnt = 0; memset(d,0,sizeof(d)); memset(k,0,sizeof(k)); clean(); scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= m; i++) scanf(“%d%d”,&amp;u[i].x,&amp;u[i].y); for(register int i = 1; i &lt;= m; i++) add(u[i].y,u[i].x); cnt = 0; work(); if(cnt &lt; n) printf(“Impossible!”); else for(register int i = n; i &gt;= 1; i–) printf(“%d “,ans[i]); printf(“\n”); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[IncDec Sequence - 题解]]></title>
    <url>%2F2019%2F08%2F02%2FIncDec%20Sequence%20-%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道练习差分的好题第一眼看到这个题，一个清晰的暴力思路就浮现与脑海之中…… 好吧，暴力是肯定要超时的，但是差分就不会了。因为修改一个长度为m的区间，暴力的复杂度是O(m),但差分的复杂度是O(1)的。 为什么会想到去用差分呢因为这道题我们是需要把所有数之间的差都变为0，而差分的实现正好于此类似。 那么，具体该怎么做呢？很简单，如果两个数的差为2，那么我们只需要操作两次即可让这两个数的值相同。所以，我们可以统计出差分数组中的正数的和与负数的和，取其中的最大值就是最少的操作次数了。具体为什么不用管少的那一个，是因为在处理多的那一个的同时少的那一个同样会被处理，且绝对值小的是会被先处理完的。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int a[100005],s[100005]; int main(){ int n,up,down; scanf(“%d”,&amp;n); for(register int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); s[1] = a[1]; for(register int i = 2; i &lt;= n; i++) { s[i] = a[i] - a[i - 1]; if(s[i] &gt; 0) up += s[i]; else down -= s[i]; } printf(“%d\n%d\n”,max(up,down),abs(up - down + 1)); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[钻石收藏家-two pointer]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%92%BB%E7%9F%B3%E6%94%B6%E8%97%8F%E5%AE%B6-two%20pointer%2F</url>
    <content type="text"><![CDATA[有splay的标签其实用two-pointer就能轻松搞定时间复杂度为O(n)我们可以发现,将数据答案一定是数据的某两个区间的长度和。对于判断一个区间是否能够被放到一个架子上，只需要判断这个区间的首尾数据的差是否超过了k。 这里，我们可以用两个two-pointer来线性枚举区间，最后枚举这两个区间之间的分割点来更新答案。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; int n,k,a[51000],l[51000],r[51000],p1,p2,maxx; int mysort(int a,int b) {return a &lt; b;} void two_pointer(){ p1 = 0; p2 = 1; for(int i = 1; i &lt;= n; i++) { p1 ++; while(a[p2] - a[p1] &lt;= k &amp;&amp; p2 &lt; n) p2 ++; if(a[p2] - a[p1] &gt; k) p2 – ; l[p1] = p2 - p1 + 1; }for(int i = n-1; i &gt; 0; i–) l[i] = max(l[i], l[i + 1]); //使用右侧的最优解更新当前节点} void tow_pointer(){ p1 = n + 1; p2 = n; for(int i = 1; i &lt;= n; i++) { p1 –; while(a[p1] - a[p2] &lt;= k &amp;&amp; p2 &gt; 1) p2 –; if(a[p1] - a[p2] &gt; k) p2 ++; r[p1] = p1 - p2 + 1; } for(int i = 2; i &amp;lt;= n; i++) r[i] = max(r[i], r[i - 1]);//使用右侧的最优解更新当前节点} int main(){ scanf(“%d%d”,&amp;n,&amp;k); for(int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); sort(a+1,a+n+1,mysort); two_pointer(); //枚举分割点右侧的区间 tow_pointer(); //枚举分割点左侧的区间 for(int i = 1; i &lt; n; i++) maxx = max(maxx, l[i + 1] + r[i]); //枚举分界点更新答案 cout &lt;&lt; maxx; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[音乐会的等待-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%9F%B3%E4%B9%90%E4%BC%9A%E7%9A%84%E7%AD%89%E5%BE%85-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 感觉这道题用单调栈做这一点还是很容易看出来的。然后我们就会发现其实现在问题变得非常的简单。每次读入一个数，就找到第一个比它小的数并进行替换，然后将前面的数全部删掉就可以了，处理每一个数的时候都要更新一下答案。 附一下代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; long long n,top; long long Ans; int a[500050],stk[500050]; void dfs(int x) { int le=0,ri=top,mid,ret=0; while(le&lt;=ri) { mid=(le+ri)&gt;&gt;1; if(a[stk[mid]]&gt;x)ret=mid,le=mid+1; else ri=mid-1; } if(!ret)Ans+=top; else Ans+=top-ret+1; } int main() { scanf("%d",&amp;n); for(int i=1; i&lt;=n; ++i)scanf("%d",&amp;a[i]); for(int i=1; i&lt;=n; ++i) { dfs(a[i]); while(top&gt;0&amp;&amp;a[i]&gt;a[stk[top]])--top; stk[++top]=i; } printf("%lld",Ans); return 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[飞行路线-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道分层图最短路的裸题分层图最短路不会的戳这里 这道题实在是太裸了，我都不知道该在说写什么了（你把分层图最短路的版子交上去貌似都能过……） 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 2147483647 using namespace std; struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}}; priority_queue&lt;node&gt; que; long long n,m,k,s,t,d[50005],cnt,D[50005][15],v[50005][15]; struct Edge{ int to,next,x;}edge[2000005]; void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;} int main(){ int x,y,a; scanf(“%lld%lld%lld”,&amp;n,&amp;m,&amp;k); scanf(“%d%d”,&amp;s,&amp;t); s ++; t ++; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;a); x ++; y ++; add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &amp;gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &amp;lt; k &amp;amp;&amp;amp; D[too][level + 1] &amp;gt; D[kk][level]) { D[too][level + 1] = D[kk][level]; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &amp;lt;= k; i++) ans = min(ans,D[t][i]); printf(&quot;%lld\n&quot;,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[骑马修栅栏-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%AA%91%E9%A9%AC%E4%BF%AE%E6%A0%85%E6%A0%8F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 我做的第一道欧拉路径的题说实话，这就一板子题…… 欧拉路径不会求的戳这里。 直接上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,x,y,head[1200],cnt,map[1030][1030],d[1030],begin,s[1030],t; void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] –; map[i][k] –; dfs(i); } } s[++t] = k;} int main(){ scanf(“%d”,&amp;m); for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d”,&amp;x,&amp;y); map[x][y] ++; map[y][x] ++; n = max(n,x); n = max(n,y); d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } if(begin == 0) begin = 1; dfs(begin); for(register int i = t; i &gt;0; i–) printf(“%d\n”,s[i]); printf(“\n”); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ant Trip-题解]]></title>
    <url>%2F2019%2F08%2F02%2FAnt%20Trip-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里因为每条边都只能走一次，所以这道题可以用欧拉路的性质来求解。我们首先用并查集去记录每一个联通块，然后再统计每一个子图的奇点数，如果是偶数则满足欧拉回路的性质直接ans++ 就好了，如果是奇数，那么需要的蚂蚁数则是奇点数/2附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register using namespace std;int read(){ register int a = 0,f = 1; register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0') {if(ch == '-') f = -1; ch = getchar();} while(ch &lt;='9' &amp;&amp; ch &gt;='0') {a = a * 10 + ch - 48; ch = getchar();} return a * f;}int n,m,x,y,s,ans,cnt,t,d[100005],fa[100005],use[100005],a[100005],add[100005];int find(int p){ if(fa[p] == p) return p; return fa[p] = find(fa[p]);}void work(){ m = read(); ans = 0; for(re int i = 1; i &lt;= n; i++) fa[i] = i; for(re int i = 1; i &lt;= n; i++) d[i] = 0; for(re int i = 1; i &lt;= n; i++) a[i] = 0; for(re int i = 1; i &lt;= n; i++) add[i] = 0; for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); d[x] ++; d[y] ++; if(find(x) != find(y)) fa[find(y)] = find(x); } for(int i = 1; i&lt;= n; i++) { a[find(i)]++; if(d[i] % 2 == 1) add[find(i)] ++; } for(int i = 1; i &lt;= n; i++) { if(a[i] &lt;= 1) continue; //只有一个点和空的点集没有边，可以忽略不计。 else if(add[i] == 0) ans += 1; else if(add[i] &gt; 0) ans += add[i]/2; } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ while(cin &gt;&gt; n) work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra-学习]]></title>
    <url>%2F2019%2F08%2F02%2FDijkstra-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言SPFA算法由于它上限O(NM)的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:dijkstra 什么是dijkstra?dijkstra是一种单源最短路径算法,时间复杂度上限为O(n^2)(朴素),在实际应用中较为稳定;加上堆优化之后更是具有O((n+m)log^2 n)的时间复杂度,在稠密图中有不俗的表现. dijkstra的原理/流程?dijkstra本质上的思想是贪心,它只适用于不含负权边的图.我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” dijkstra的流程如下: 初始化dis[start] = 0,其余节点的dis值为无穷大. 找一个dis值最小的蓝点x,把节点x变成白点. 遍历xx的所有出边(x,y,z)，若dis[y] &gt; dis[x] + z,则令dis[y] = dis[x] + z 重复2,3两步,直到所有点都成为白点.dijkstra为什么是正确的当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第2步中找出的蓝点x必然满足:dis[x]已经是起点到x的最短路径.我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度图解(令start = 1)开始时我们把dis[start]初始化为0,其余点初始化为inf第一轮循环找到dis值最小的点1,将1变成白点,对所有与1相连的蓝点的dis值进行修改,使得dis[2]=2,dis[3]=4,dis[4]=7第二轮循环找到dis值最小的点2,将2变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[3]=3,dis[5]=4第三轮循环找到dis值最小的点3,将3变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[4]=4接下来两轮循环分别将4,5设为白点,算法结束,求出所有点的最短路径 为什么dijkstra不能处理有负权边的情况?我们来看下面这张图2到3的边权为−4,显然从1到3的最短路径为−2 (1-&gt;2-&gt;3).但在循环开始时程序会找到当前dis值最小的点3,并标记它为白点.这时的dis[3]=1,然而1并不是起点到3的最短路径.因为3已经被标为白点,所以dis[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. dijkstra的堆优化?观察dijkstra的流程,发现步骤2可以优化怎么优化呢?我们可以用堆对disdis数组进行维护,用O(logn)的时间取出堆顶元素并删除,用O(logn)的时间遍历每条边,总复杂度O((n+m)\log^2 n).附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); } que.push((node){s,0}); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) { node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) { if(D[edge[i].to] &gt; D[u.k] + edge[i].x) { D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node){edge[i].to,D[edge[i].to]}); } } } for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Largest Rectangle in a Histogram-题解]]></title>
    <url>%2F2019%2F08%2F02%2FLargest%20Rectangle%20in%20a%20Histogram-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里我们用单调栈来维护每一个小矩形的左侧和右侧第一个比它低的矩形的位置。为什么要维护这个呢？根据木桶原理，每一个大矩形的高度是由其高度最小的矩形的高度决定的，所以我们要去记录第一个比当前矩形小的矩形的位置。ps：别忘了初始化qwq……附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define pie 3.1415926using namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int n,t,q,l[100005],r[100005],sta[100005],p;struct build{ int x,h;}b[100005];void init1(int k){ if(p == 0) { sta[++p] = k; return ; } if(b[k].h &gt;= b[sta[p]].h) { sta[++p] = k; return ; } while(b[sta[p]].h &gt; b[k].h &amp;&amp; p) { l[sta[p]] = k; p --; } sta[++p] = k;}void init2(int k){ if(p == 0) { sta[++p] = k; return ; } if(b[k].h &gt;= b[sta[p]].h) { sta[++p] = k; return ; } while(b[sta[p]].h &gt; b[k].h &amp;&amp; p) { r[sta[p]] = k; p --; } sta[++p] = k;}ll ans;int main(){ n = read(); while(n != 0) { ans = 0; memset(b,0,sizeof(b)); for(int i = 1; i &lt;= n; i++) { b[i].h = read(); b[i].x = i; } p = 0; for(int i = 1; i &lt;= n + 1; i++) init1(i); p = 0; for(int i = n; i &gt;= 0; i--) init2(i); for(int i = 1; i &lt;= n; i++) { ans = max(ans,1LL * (l[i] - r[i] - 1) * b[i].h); } printf("%lld\n",ans); n = read(); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[分层图最短路-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ARX：我今天上午做了两个分层图最短路的题，可简单了……概念 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 算法思路这是一个类似于DP的思路。用直接通过的边把整个图分成k个子图，其中k为可以直接通过的边的个数。在此基础上，我们直接跑最短路算法就可以了。 算法细节在处理子图与子图之间的关系时，由于连接两个子图的路径是可以直接通过的，所以我们在记录下一层的路径长度时，转移方程为:if(d[edge[i].to][level + 1] &lt; d[u][level] &amp;&amp; level &lt; k) d[edge[i].to][level + 1] = d[u][level];其中edge[i]是一条以节点u为起点的边。注意，由于图的层数有限，所以level &lt; k这一条件一定不要忘记加。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,k,s,t,d[50005],cnt,D[50005][15],v[50005][15]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); scanf("%d%d",&amp;s,&amp;t); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &lt; k &amp;&amp; D[too][level + 1] &gt; D[kk][level]) { D[too][level + 1] = D[kk][level]; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &lt;= k; i++) ans = min(ans,D[t][i]); printf("%lld\n",ans); return 0;} 推荐练习题目：飞行路线、冻结、回家的路]]></content>
  </entry>
  <entry>
    <title><![CDATA[小Z的袜子-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 突然感觉qxy和小z是同种生物莫队的一道裸题虽说莫队算是一种暴力的算法，但ta依然是某些题目的正解的。（dfs：我不服） 这道题是需要我们经过一定的数学推导才可以做出来的。具体过程如下：对于L,R的询问。 设其中颜色为x,y,z的袜子的个数为a,b,c… 那么答案即为 (a*(a-1)/2+b*(b-1)/2+c*(c-1)/2....)/((R-L+1)*(R-L)/2) 化简得: (a^2+b^2+c^2+...x^2-(a+b+c+d+.....))/((R-L+1)*(R-L)) 即： (a^2+b^2+c^2+...x^2-(R-L+1))/((R-L+1)*(R-L)) 于是这道题目变成了求a^2+b^2+c^2+...x^2，这个过程我们可以用莫队去实现。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffffusing namespace std;long long read(){ long long x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0'){if(ch == '-') f = -f; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x * 10 + ch - '0'; ch = getchar();} return x * f;}long long gcd(long long a, long long b){return a == 0 ? b : gcd(b % a, a);}long long n,m,a[50005],xsort,p1,p2,t[50005],ans,cnt,g,ll,rr,in[50005],save1[50005],save2[50005];struct query{ long long l,r,num;}q[50005];long long mysort(query x, query y){ if(x.l / xsort == y.l / xsort) return x.r &lt; y.r; return x.l &lt; y.l;}long long work(long long x){ return x * x;}void add(long long k){ long long u = a[k]; if(k == 0) return ; ans = ans - work(t[u]); t[u] ++; ans = ans + work(t[u]);}void del(long long k){ long long u = a[k]; if(k == 0) return ; ans = ans - work(t[u]); t[u] --; ans = ans + work(t[u]);}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i ++) a[i] = read(); for(re int i = 1; i &lt;= m; i++) { q[i].l = read(); q[i].r = read(); q[i].num = i; } xsort = sqrt(n); sort(q + 1, q + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) { ll =q[i].l; rr = q[i].r; while(p1 &lt; ll){del(p1); p1 ++;} while(p1 &gt; ll){p1 --; add(p1);} while(p2 &lt; rr){p2 ++; add(p2);} while(p2 &gt; rr){del(p2); p2 --;} cnt = (rr - ll + 1) * (rr - ll); save1[q[i].num] = ans - (rr - ll + 1); save2[q[i].num] = cnt; } for(re int i = 1; i &lt;= m; i++) { if(save1[i] != 0 &amp;&amp; save2[i] != 0) g = gcd(save1[i],save2[i]); else g = 1; if(save1[i] == 0 || save2[i] == 0) {printf("0/1\n"); continue ;} printf("%d/%d\n",save1[i] / g,save2[i] / g); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[无线通讯网-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%97%A0%E7%BA%BF%E9%80%9A%E8%AE%AF%E7%BD%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[直到敲完这个题，我才发现原来prim如果用邻接矩阵存图即使加上堆优化时间复杂度依然是O(n2)qwq…… 首先，由于两个点只需要间接联通就可以互相通讯，所以这道题可以用最小生成树去做。这一步比较好完成。 问题在于怎么去加卫星电话。由于两个点只要间接联通就可以，那么每一个用无线电收发器连成的子图只需要有一个卫星电话即可与其它的点联通，所以我们在删边的时候需要先判断一下这两个点删完边以后是不是仍然联通而不是傻傻地给这两个点都安装上卫星电话（被这个卡了好久qwq） 如图所示，由于2、4号点都安装了电话，所以删掉边1-3后，1、3号点之间就不需要安装电话的。 再来看如何安装电话。如图，我们可以发现，当前两个点安装完卫星电话以后，每一个子图都会拥有一个卫星电话。当我们继续删边时，分成的两个新的子图都是一个有卫星电话，一个没有，所以我们从第二次开始每次删边只需要增加一部卫星电话即可。所以最终留下的最大的边是第s大的边（由于第一次删边你需要安装两台卫星电话，所以你最多只能删s - 1条边）附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct NODE{ int x, y, num; double minn;}a[1000];int s,p,vis[1000],del[1000],fa[1000],f[1000];struct node{ int k; double dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue &lt;node&gt; que;int mysort(NODE a, NODE b){return a.minn &gt; b.minn;}int main(){ s = read(); p = read(); for(re int i = 1; i &lt;= p; i++) { a[i].x = read(); a[i].y = read(); a[i].num = i; } for(re int i = 1; i &lt;= p; i++) a[i].minn = INF; que.push((node){1,0}); vis[1] = 1;a[1].minn = 0; while(!que.empty()) { node now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = 1; i &lt;= p; i++) { if(!vis[i] &amp;&amp; sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))) &lt; a[i].minn) { a[i].minn = sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))); que.push((node){i,a[i].minn}); fa[i] = now.k; } } } sort(a + 1, a + p + 1, mysort); int j = 1; double Min = a[j].minn; Min = a[s].minn; printf("%.2lf\n",Min); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[·拓扑排序是什么呢？我们先来看一下标准解释：对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。 额，是不是有点懵……其实，通俗易懂地说，拓扑排序就是在一个DAG中，对所有的节点进行排序，要求在序列中没有一个节点有边指向序列中它前面的节点。 ·那么，我们该怎么去实现呢？其实，求拓扑排序的过程，就是一个不断寻找入度为零的点和删边的过程。 如果一个点的入度为零，那么它一定可以直接被选（因为任何目前没有被选择的点都不可能在有边连向这一个点了）。每当我们选择一个点放入序列后，我们就要把所有以这个节点为起点的边都删掉，并更新其它点的入度。 tip：对于同一个图，拓扑排序后可能存在多种合法答案。 附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; queue&lt;int&gt;que; //拓扑排序的过程也不一定用队列去实现 int t,n,m,x,y,cnt,d[100005],k[100005],ans[100005]; struct Edge{ int to,next; }edge[100005]; void add(int x,int y) { edge[++cnt].to = y; edge[cnt].next = d[x]; d[x] = cnt; k[y] ++; } void work() { for(register int i = 1; i &lt;= n; i++) if(k[i] == 0) que.push(i); //将所有入度为0的点入队 //cout &lt;&lt; que.top()&lt;&lt;endl; while(!que.empty()) { x = que.front(); //取队首元素 ans[++cnt] = x; //ans记录答案 que.pop(); for(register int i = d[x]; edge[i].to != 0; i = edge[i].next) { k[edge[i].to] --; //更新其它节点的入度 if(k[edge[i].to] == 0) //若入度为0，则将这个节点入队 que.push(edge[i].to); } } } int main() { cin &gt;&gt; n &gt;&gt; m; //表示有n个点，m条边 for(int i = 1; i &lt;= m ;i++) //存边 { cin &gt;&gt; x&gt;&gt;y; add(x,y); } cnt = 0; work(); //拓扑排序 for(register int i = 1; i &lt;= n; i++) printf("%d ",ans[i]); return 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[最短路计数-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 虽然题目叫最短路计数，但是TA可以只用到最短路的概念而不用最短路的算法……由于这是一个无权图，所以一条路径上边的数量就是这条路径的长度，那么我们就可以用BFS来搞定这个问题了。 具体思路我们每遍历到一个节点就和ta的前一个结点的距离比较，这里会有三种情况：(由1到2) 2号点没有被访问过||time[1] + 1 &lt; time[2]：此时我们直接用1号点的信息去更新2就好啦 time[1] + 1 = time[2] : 这个我们就只需要更新一下ans就可以啦 time[1] + 1 &gt; time[2] :此时这条路径比之前的某条路径要长，直接跳过就可以啦代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}queue&lt;int&gt; que;struct edge{ int next,to,v;}e[2000005];int n,m,cnt,x,now,y,tim[2000000],ans[2000000],d[2000000];inline int add(int x,int y){ e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); add(x,y); add(y,x); } que.push(1); ans[1] = 1; while(!que.empty()) { now = que.front(); que.pop(); for(re int i = d[now]; i; i = e[i].next) { if(tim[now] + 1 &lt; tim[e[i].to] || tim[e[i].to] == 0) { tim[e[i].to] = tim[now] + 1; ans[e[i].to] = ans[now]; que.push(e[i].to); } else if(tim[now] + 1 == tim[e[i].to]) ans[e[i].to] = (ans[e[i].to] + ans[now]) % 100003; } } ans[1] = 1; for(re int i = 1; i &lt;= n; i++) printf("%d\n",ans[i]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[求和-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 前言 没有什么是吸一口氧气解决不了的，如果有，就再吸一口…… 算法朴素暴力 首先，看到这道题的第一时间就想到了一个暴力的方法——枚举每一个x点和x与z的间距（只需要枚举偶数间接即可，否则无法满足y−x=z−y）。然而，这个算法是$O(n^2)$的，我们无法承受这个时间复杂度。 优化暴力思路 其实感觉还是挺慢的，需要吸一口氧气才能过 由于朴素的暴力需要枚举每一个起点和间接，但是如果我们对数据排一下序呢？ 是的，这样我们就可以不必枚举每一个间距了。但是呢，由于这个方法本质还是一个暴力，我们在统计答案的时候速度会比较慢qwq 排序 那么，我们怎么去进行排序呢？ 我们可以发现，y的值对于答案是没有任何影响的，只要x和z的编号同为奇数或偶数，那么就一定存在一个y使得y−x=z−y。所以，我们在排序时的关键字的优先级应该时这样的： 1. 颜色 2. 序号的奇偶（可以偶数在前，也可以奇数在前，但必须保证统一颜色的奇数和偶数编号的点是挨着的） 3. 序号的大小（感觉这个其实没什么用qwq） 然后我们只需要枚举每一个颜色和奇偶均相同的区间并统计答案即可代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define mod 10007using namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct number{ ll num,col,x;}a[100005];ll n,m,s,ans;int mysort(number a, number b){ if(a.col != b.col) return a.col &lt; b.col; if(a.num % 2 == b.num % 2) return a.num &lt; b.num; return a.num % 2 &lt; b.num % 2;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i++) a[i].num = i; for(re int i = 1; i &lt;= n; i++) a[i].x = read(); for(re int i = 1; i &lt;= n; i++) a[i].col = read(); sort(a + 1, a + n + 1, mysort); int i = 1; while(i &lt;= n){ s = i; while(a[i].col == a[i + 1].col &amp;&amp; a[i].num % 2 == a[i + 1].num % 2 &amp;&amp; i &lt; n) i ++; for(int j = s; j &lt; i; j++) for(int k = j + 1; k &lt;= i; k++) ans = (ans + (a[j].num + a[k].num) * (a[j].x + a[k].x)) % mod; i++; } printf("%lld\n",ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[滑雪-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%BB%91%E9%9B%AA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 解题思路首先，因为题目要求求“即满足经过景点数最大的前提下使得滑行总距离最小”，所以这道题目我们可以用最小生成树来解决。 具体做法核心算法 这里推荐用kruskal去求最小生成树(prim虽然加上堆优化也应该不会超时，但是ta真的是代码难敲效率还低qwq)。 因为这道题目对于每个点的高度都有一个限制，所以有些点即使是有边相连也是到不了的。此时我们可以先统计可以到达的边，然后只储存两个端点都可以到达的边。 注意事项 因为每个点具有高度，所以建边是应根据情况选择建单向边还是双向边。 由于每个点的高度都有限制，所以并不是某个点在一开始统计的时候统计为能到达就可以随意选边。 如图，如果我们直接按照边权从小到大排序，那么我们会选择（2）号边。但实际上，3号点是到不了4号点的，所以我们应优先选择终点高度高的（1）号边。 因此我们在对边进行排序是，应把终点的高度设为第一关键字，把边权设为第二关键字 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge1{ int next,to,k,from;}edge[2000005];struct edge2{ int x,y,k;}e[2000005];long long n,m,u,v,k,t,cnt,ans,tot,h[100005],d[100005],vis[100005],fa[100005];void add(int x, int y, int k){ edge[++cnt].to = y; edge[cnt].k = k; edge[cnt].next = d[x]; edge[cnt].from = x; d[x] = cnt;}void dfs(int s){ vis[s] = 1; for(re int i = d[s]; i; i = edge[i].next) if(!vis[edge[i].to]) dfs(edge[i].to);}int mysort(edge2 a, edge2 b){ if(h[a.y] != h[b.y]) return h[a.y] &gt; h[b.y]; return a.k &lt; b.k;}int find(int x) {if(fa[x] == x) return x; return fa[x] = find(fa[x]);}void kruskal(){ for(re int i = 1; i &lt;= n; i++) fa[i] = i; sort(e + 1, e + t + 1, mysort); for(re int i = 1; i &lt;= t; i++) { if(find(e[i].x) != find(e[i].y)) { ans = ans + e[i].k; fa[find(e[i].x)] = find(e[i].y); } }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i++) h[i] = read(); for(re int i = 1; i &lt;= m; i++) { u = read(); v = read(); k = read(); if(h[u] &gt;= h[v]) add(u,v,k); if(h[u] &lt;= h[v]) add(v,u,k); } dfs(1); for(re int i = 1; i &lt;= cnt; i ++) { if((edge[i].from != edge[i - 1].to || edge[i].to != edge[i - 1].from) &amp;&amp; vis[edge[i].from] &amp;&amp; vis[edge[i].to]) { e[++t].k = edge[i].k; e[t].x = edge[i].from; e[t].y = edge[i].to; } } kruskal(); for(re int i = 1; i &lt;= n; i++) if(vis[i]) tot ++; printf("%lld %lld\n", tot, ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[定义欧拉路径（欧拉通路）：通过图中所有边的简单路。（换句话说，每条边都通过且仅通过一次）也叫”一笔画”问题。欧拉回路：闭合的欧拉路径。（即一个环，保证每条边都通过且仅通过一次）欧拉图：包含欧拉回路的图。 起源在一个图中求解一条欧拉回路的问题，起源于欧拉提出的、著名的“七桥问题”。详见百度百科。 判定欧拉路径： 1.图G是连通的，无孤立点。2.无向图奇点数为0或2，并且这两个奇点其中一个为起点另外一个为终点。有向图，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。 欧拉回路 1.图G是连通的，无孤立点。2.无向图奇点数为0；有向图每个点的入度必须等于出度。 算法求欧拉回路的算法中，普遍使用的是Fleury算法和Hierholzer算法。由于Hierholzer算法在时间复杂度和代码实现上都更优，所以这里只介绍一下Hierholzer算法。主要是我不会敲Fleury…… Hierholzer算法思路 1.根据每个点的入度选择起点。2.运用DFS去遍历当前节点的每一条边，之后将该节点压入栈中。3.操作2接受后，栈中的元素就是一条欧拉回路。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define INF 0x7fffffff#define ll long longusing namespace std;int n,m,x,y,head[1200],cnt,map[1030][1030],d[1030],begin,s[1030],t;void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] --; map[i][k] --; dfs(i); } } s[++t] = k;}int main(){ scanf("%d",&amp;m); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d",&amp;x,&amp;y); map[x][y] ++; map[y][x] ++; n = max(n,x); n = max(n,y); d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } if(begin == 0) begin = 1; dfs(begin); for(register int i = t; i &gt;0; i--) printf("%d\n",s[i]); printf("\n"); return 0;} 推荐联系题目：骑马修栅栏、无序字母对]]></content>
  </entry>
  <entry>
    <title><![CDATA[银河英雄传说-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 算法思路题目中一共给了合并和查询和两种操作，很显然我们可以用并查集来实现。但是，查询操作需要给出两个点之间的距离，那么我们怎么去统计这个量呢？如图，我们可以发现，如果我们想要知道4号点到2号点的距离，如果不压缩路径，我们可以选择一步步去统计这两个点到祖先的距离，然后进行计算。但是，1e5的数据显然是不支持这个时间复杂度的。那么，我们该怎么做呢？答案就是用加权并查集。 加权并查集和朴素并查集的区别是并查集在统计某节点的父亲节点的同时，还统计该节点到ta的祖先节点的距离。这样，我们就可以进行路径压缩而不是只能一步一步往上跳。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}const int n = 30000;int fa[100005],dis[100005],siz[100005],t,x,y;char s;int query(int x){ if(fa[fa[x]] == fa[x]) return dis[x]; return dis[x] + dis[query(fa[x])];}int find(int x){ if(fa[x] == x) return x;// dis[x] = query(x); int ans = find(fa[x]); dis[x] = dis[fa[x]] + dis[x]; fa[x] = ans; return ans;}int main(){ t = read(); for(int i = 1; i &lt;= n; i ++) fa[i] = i; for(int i = 1; i &lt;= n; i ++) siz[i] = 1; for(int i = 1; i &lt;= t; i ++) { cin &gt;&gt; s; x = read(); y = read(); if(s == 'M') { int fx = find(x),fy = find(y); if(find(x) != find(y)) { dis[fx] = dis[fx] + siz[fy]; siz[fy] += siz[fx]; siz[fx] = 0; fa[fx] = fy; } } if(s == 'C') { if(find(x) != find(y)) { printf("-1\n"); continue; } if(x == y) { printf("0\n"); continue; } printf("%d\n",abs(dis[x] - dis[y]) - 1); } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[食物链-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%A3%9F%E7%89%A9%E9%93%BE-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 和关押罪犯差不多，也是一个种类并查集的题目。不过关押罪犯有两个种类，而这个题复杂一些，有三个种类，但大体思路都是一样的，我们只需要开三倍空间就可以了。对于每一句话，我们只需要判断它和前面的记录是否冲突，若冲突，则让ans + 1，否则按照这句话的要求去修改。 Tips： 因为要开三倍空间，所以我们在初始化的时候也要对这三倍的空间都进行初始化。 在每次更新的时候，我们都要将这三倍的空间分别更新。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;int n,m,s,x,y,ans,f[150005];int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);}int main(){ scanf("%d%d",&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) { f[i] = i; f[i + n] = i + n; f[i + n + n] = i + n + n; } for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;s,&amp;x,&amp;y); if(x &gt; n || y &gt; n) { ans ++; continue ; } if(s == 1) { if(find(x) == find(y + n) || find(y) == find(x + n)) { ans ++; continue ; } f[find(x)] = f[find(y)]; f[find(x + n)] = f[find(y + n)]; f[find(x + n + n)] = f[find(y + n + n)]; } if(s == 2) { if(find(x) == find(y) || find(x + n) == find(y)) { ans ++; continue ; } f[find(x)] = f[find(y + n)]; f[find(x + n)] = f[find(y + n + n)]; f[find(x + n + n)] = f[find(y)]; } } printf("%d\n",ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[splay-学习]]></title>
    <url>%2F2019%2F08%2F02%2Fsplay-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[其实……说实话我还真的不是非常会用qwq先存一下板子把，以后慢慢来qwq 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffff#define ll long longusing namespace std;int read(){ int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0'){if(ch == '-') f = -f; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x * 10 + ch - '0'; ch = getchar();} return x * f;}struct node{ int fa,son[2],v,tie,siz;}e[1000000];int root,tot;void rotate(int x){ int y = e[x].fa, z = e[y].fa, mode = 0; if(e[z].son[0] == y) e[z].son[0] = x; else e[z].son[1] = x; e[x].fa = z; if(e[y].son[0] == x) mode ++; e[y].son[mode ^ 1] = e[x].son[mode]; e[e[x].son[mode]].fa = y; e[x].son[mode] = y; e[y].fa = x; e[y].siz = e[e[y].son[0]].siz + e[e[y].son[1]].siz + e[y].tie; e[x].siz = e[e[x].son[0]].siz + e[e[x].son[1]].siz + e[x].tie;}void splay(int x){ while(e[x].fa) { int y = e[x].fa, z = e[y].fa; if(z) { if((e[y].son[0] == y) ^ (e[y].son[0] == x)) rotate(x); else rotate(y); } rotate(x); } root = x;}int find(int now, int w){ while(e[now].v != w) { if(w &lt; e[now].v) { if(e[now].son[0]) now = e[now].son[0]; else break; } else { if(e[now].son[1]) now = e[now].son[1]; else break; } } return now;}void add(int f, int w){ e[++ tot].fa = f; e[tot].tie = 1; e[tot].siz = 1; e[tot].v = w;}void ins(int p){ if(!tot) { add(0,p); root = 1; return ; } int pos = find(root,p); if(e[pos].v == p) e[pos].tie ++; else { add(pos,p); if(p &lt; e[pos].v) e[pos].son[0] = tot; else e[pos].son[1] = tot; } for(int now = pos; now; ++e[now].siz,now = e[now].fa); if(e[pos].v == p) splay(pos); else splay(tot);}void del(int p){ int pos = find(root,p); if(e[pos].v != p) return ; splay(pos); if(e[pos].tie &gt; 1) { e[pos].tie --; e[pos].siz --; return ; } if(!e[pos].son[0]) { e[e[pos].son[1]].fa = 0; root = e[pos].son[1]; if(!root) tot = 0; } else { e[e[pos].son[0]].fa = 0; int lax = find(e[pos].son[0],1000000); splay(lax); e[root].siz += e[e[pos].son[1]].siz; e[root].son[1] = e[pos].son[1]; e[e[pos].son[1]].fa = root; } e[pos].v = 0; e[pos].tie = 0; e[pos].siz = 0; e[pos].fa = 0; e[pos].son[0] = 0; e[pos].son[1] = 0;}int rank(int p){ int pos = find(root,p); splay(pos); return e[e[pos].son[0]].siz + 1;}int k_th(int p){ int now = root; for(int bot = e[e[now].son[0]].siz; p &lt;= bot || p &gt; bot + e[now].tie; bot = e[e[now].son[0]].siz) if(p &gt; bot + e[now].tie) { p = p - bot - e[now].tie; now = e[now].son[1]; } else now = e[now].son[0]; return e[now].v;}int pred(int p){ int pos = find(root,p); if(e[pos].v &lt; p) return e[pos].v; splay(pos); return e[find(e[pos].son[0],10000000)].v;}int succ(int p){ int pos = find(root,p); if(e[pos].v &gt; p) return e[pos].v; splay(pos); return e[find(e[pos].son[1],0)].v;}int main(){// freopen("a.txt","w",stdout); int m,mode,x; scanf("%d",&amp;m); while (m--) { scanf("%d%d",&amp;mode,&amp;x); switch (mode) { case 1:ins(x);break; case 2:del(x);break; case 3:printf("%d\n",rank(x));break; case 4:printf("%d\n",k_th(x));break; case 5:printf("%d\n",pred(x));break; case 6:printf("%d\n",succ(x));break; } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[树的直径定义 给定一棵树，树中每条边都有一个权值，树中两点之间的距离定义为连接两点的路径边权之和。树中最远的两个节点之间的距离被称为树的直径，连接这两点的路径被称为树的最长链。后者通常也可称为直径，即直径是一个数值概念，也可代指一条路径 性质 直径两端点一定是两个叶子节点 距离任意点最远的点一定是直径的一个端点，这个基于贪心求直径方法的正确性可以得出 对于两棵树，如果第一棵树直径两端点为(u,v)，第二棵树直径两端点为(x,y)，用条边将两棵树连接，那么新树的直径一定是u,v,x,y中的两个点 对于一棵树，如果在一个点的上接一个叶子节点，那么最多会改变直径的一个端点 若一棵树存在多条直径，那么这些直径交于一点且交点是这些直径的中点算法求树的直径有两种算法,一种是跑两边搜索,另一种是用树形DP去求(可惜我不会qwq)这里我们来介绍用两遍搜索求树的直径的方法.首先,我们从任意一个点出发,找出和ta的距离最远的点u;然后再从u出发,搜索树上距离u最远的节点v.u和v之间的路径就是树的直径.证明:OI不需要证明……代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int next,to,v;}e[100005];int n,m,x,y,z,cnt,maxx,j,d[100005],vis[100005],last[100005];void add(int x, int y, int z){ e[++cnt].to = y; e[cnt].v = z; e[cnt].next = d[x]; d[x] = cnt;}void dfs(int k, int l){ if(l &gt; maxx) { maxx = l; j = k; } for(re int i = d[k]; i; i = e[i].next) if(!vis[e[i].to]) { vis[e[i].to] = 1; last[e[i].to] = k; dfs(e[i].to,l + e[i].v); }}void work(){ vis[1] = 1; dfs(1,0); memset(vis,0,sizeof(vis)); memset(last,0,sizeof(last)); maxx = 0; vis[j] = 1; dfs(j,0); printf("%d\n",maxx); while(j != 0) { printf("%d ",j); j = last[j]; }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); z = read(); add(x,y,z); add(y,x,z); } work(); return 0;} 树的重心定义 树的重心也叫树的质心。对于一棵树n个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。换句话说，删除这个 点后最大连通块（一定是树）的结点数最小。 性质 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 一棵树最多有两个重心，且相邻。算法和树的最大独立问题类似，先任选一个结点作为根节点，把无根树变成有根树，然后设d(i)表示以i为根的子树的结点的个数。不难发现d(i)=∑d(j)+1，j∈s（i）。s（i）为i结点的所有儿子结点的编号的集合。程序也十分简单：只需要DFS一次，在无根树有根数的同时计算即可，连记忆化都不需要——因为本来就没有重复计算。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int next,to,v;}e[100005];int n,m,x,y,z,cnt,maxx,j,d[100005],vis[100005],last[100005];void add(int x, int y, int z){ e[++cnt].to = y; e[cnt].v = z; e[cnt].next = d[x]; d[x] = cnt;}void dfs(int k, int l){ if(l &gt; maxx) { maxx = l; j = k; } for(re int i = d[k]; i; i = e[i].next) if(!vis[e[i].to]) { vis[e[i].to] = 1; last[e[i].to] = k; dfs(e[i].to,l + e[i].v); }}void work(){ vis[1] = 1; dfs(1,0); memset(vis,0,sizeof(vis)); memset(last,0,sizeof(last)); maxx = 0; vis[j] = 1; dfs(j,0); printf("%d\n",maxx); while(j != 0) { printf("%d ",j); j = last[j]; }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); z = read(); add(x,y,z); add(y,x,z); } work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 暴力做法枚举呗……时间复杂度$O(n^2)$。显然，这种复杂度不是我们可以接受的 线段树做法ps： 感觉这东西还是暴力……由于这道题目问的是区间的最大值和最小值，所以我们可以用线段树去解决。（只有查询，可好敲了）但是呢，由于线段树的复杂度是$O(nlogn)$的，而且ta常数比较大，所以会超时qwq附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;malloc.h&gt; #define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct tree{ int maxx,minn; tree *lson,*rson;}*root = (tree*)malloc(sizeof(tree));struct node{ int a,b;}ans[1000005];void build(tree *tre,int l,int r){ if(l == r) { tre -&gt; maxx = read(); tre -&gt; minn = tre -&gt; maxx; return; } int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; maxx = max(tre -&gt; lson -&gt; maxx,tre -&gt; rson -&gt; maxx); tre -&gt; minn = min(tre -&gt; lson -&gt; minn,tre -&gt; rson -&gt; minn);}node query(tree *tre,int l,int r,int x,int y){ if(l == r) return (node){tre -&gt; maxx,tre -&gt; minn}; int mid = (l + r) &gt;&gt; 1; node t1,t2; t1.a = -INF; t1.b = INF; t2.a = -INF; t2.b = INF; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return (node){max(t1.a,t2.a),min(t1.b,t2.b)};}int main(){ int n,k; n = read(); k = read(); build(root,1,n); for(int i = 1; i &lt;= n - k + 1; i++) ans[i] = query(root,1,n,i,i + k - 1); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].b); printf("\n"); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].a); printf("\n"); return 0;} 单调队列做法终于到正解了……直接用单调队列瞎搞一下就可以啦，时间复杂度是$O(n)$的对于每次入队，我们都要判断一下，如果该数大于队尾，则直接入队，否则将队列中所有比ta小的数字全部出队，然后再入队，这样就能保证队列的单调性。对于每次出队，我们都要判断一下要出队的元素是否还在队列中（可能在别的元素入队的时候出队了）附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int n,k,a[1000005],que[1000006],head=1,tail;void q_push1(int k){ if(head &gt; tail) { que[++tail] = k; return ; } if(k &lt;= que[tail]) { que[++tail] = k; return ; } while(que[tail] &lt; k &amp;&amp; tail &gt;= head) tail--; que[++tail] = k;}void q_push2(int k){ if(head &gt; tail) { que[++tail] = k; return ; } if(k &gt;= que[tail]) { que[++tail] = k; return ; } while(que[tail] &gt; k &amp;&amp; tail &gt;= head) tail--; que[++tail] = k;}int main(){ n = read(); k = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) { if(i - k &gt; 0) if(a[i - k] == que[head]) head ++; q_push2(a[i]); if(i &gt;= k)printf("%d ",que[head]); } printf("\n"); head = 1; tail = 0; for(int i = 1; i &lt;= n; i++) { if(i - k &gt; 0) if(a[i - k] == que[head]) head ++; q_push1(a[i]); if(i &gt;= k)printf("%d ",que[head]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[最长上升/下降子序列-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%2F%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是线性DP的知识我们来看这样一个问题： 给定一个长度为n的序列，求它的最长上升子序列。好吧，相信这道题大家都见过(至少现在已经见过了)，那么我们该怎么做呢？ ·$n^{2}$做法对于这个序列，我们可以倒着处理：我们可以在开一个f数组，其中f[i]记录从原数组的第i位到第n位的最长上升子序列的长度。这样，我们只需要更新f数组，再找出f数组的中元素的最大值就可以了。附一下代码： #include&lt;iostream&gt; using namespace std; int i,j,n,a[100],b[100],max; int main() { cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; b[0]=1; //初始化，以a[0]结尾的最长递增子序列长度为1 for(i=1;i&lt;n;i++) { b[i]=1;//b[i]最小值为1 for(j=0;j&lt;i;j++) if(a[i]&gt;a[j]) b[i]=max(b[i],b[j]+1); } for(max=i=0;i&lt;n;i++) if(b[i]&gt;max) max=b[i]; cout&lt;&lt;max&lt;&lt;endl; } ·nlogn做法我们会发现，有很多题目的数据范围并不允许你的时间复杂度到达$n^{2}$。所以，掌握nlogn的做法是非常必要的。 那么，怎么在nlogn的时间复杂度内完成这件事情呢？对于nlogn的做法，我们可以用单调栈去实现。首先，什么是单调栈呢？顾名思义，单调栈，就是站内元素是单调的栈。每当我们读入一个元素，就把这个元素与栈顶的元素比较，若此元素比栈顶元素大，则直接把这个元素入栈，否则用这个元素去更新栈中第一个比这个元素大的元素。在寻找栈中第一个比这个元素大的元素时，我们可以用二分查找去实现 (当然，如果嫌麻烦，也可以直接用lower_bound和upper_bound去查询）。 附一下代码： #include &lt;iostream&gt; using namespace std; int i,j,n,s,t,a[100001]; int main() { cin&gt;&gt;n; a[0]=-1000000; for(i=0;i&lt;n;i++) { cin&gt;&gt;t; if(t&gt;a[s]) a[++s]=t; else { int l=1,h=s,m; while(l&lt;=h) { m=(l+h)/2; if(t&gt;a[m]) l=m+1; else h=m-1; } a[l]=t; } } cout&lt;&lt;s&lt;&lt;endl; }推荐练习题目：导弹拦截、寻找最优美做题曲线]]></content>
  </entry>
  <entry>
    <title><![CDATA[最小生成树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[隔了几个月，又开始写博客了qwq kruskal时间复杂度为O(nlogn)它的算法思路是这样的：我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,q[6000];struct lalala{ int x,y,z,save;}a[210000];int mysort(lalala a,lalala b){ return a.z &lt; b.z;}int work(int x,int y){ while(q[q[x]] != q[x]) q[x] = q[q[x]]; while(q[q[y]] != q[y]) q[y] = q[q[y]]; if(q[x] == q[y]) return 1; else { q[q[y]] = q[x]; return 0; }}int main(){ long long ans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) q[i]=i; for(int i=1; i&lt;=m; i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z; ans += a[i].z; } sort(a+1,a+m+1,mysort); for(int i=1;i&lt;=m;i++) { if(!work(a[i].x,a[i].y)) ans -= a[i].z; } cout &lt;&lt; ans; return 0;} prim时间复杂度O(n2)跑得慢，代码长，没特殊功能，真不知道为什么要学它qwq……prim的思想和某最短路算法的思路是类似的，我们将更新过的点标为白色，没有更新过的标为蓝色，然后枚举每一个蓝点（按minn值从小到大更新，这里貌似可以用堆优化，然而我比较懒qwq）并更新为白点，并用它去更新其他的蓝点（这里不用把被更新的点标为白色，不然它们就没法更新其他点，也没法被其他的点更新了）。最后将每个点的minn值加起来就好啦。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); } que.push((node){s,0}); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) { node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) { if(D[edge[i].to] &gt; D[u.k] + edge[i].x) { D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node){edge[i].to,D[edge[i].to]}); } } } for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;} prim的堆优化既然prim和某最短路算法的思路是相似的，那么ta和某最短路算法一样也可以用堆优化，可以把时间复杂度从O(n2)降到O(nlongn)依然是跑得慢，代码长，没特殊功能qwq……附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int x,y,z;}a[500005];struct EDGE{ int next,to,x,save;}e[500005];struct node{ int k,dis; bool operator &lt; (const node &amp; x) const {return x.dis &lt; dis;}}now;priority_queue &lt;node&gt; que;int cnt,d[100005];void add(int x,int y,int a){ e[++cnt].to = y; e[cnt].x = a; e[cnt].next = d[x]; d[x] = cnt;}int n,m,q,x,y,z,ans,minn[100005],vis[100005];int mysort(edge a1, edge a2){ if(a1.x != a2.x) return a1.x &lt; a2.x; if(a1.y != a2.y) return a1.y &lt; a2.y; return a1.z &lt; a2.z;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { a[i].x = read(); a[i].y = read(); a[i].z = read(); } sort(a + 1, a + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) if(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) { add(a[i].x, a[i].y, a[i].z); add(a[i].y, a[i].x, a[i].z); } for(re int i = 1; i &lt;= n; i++) minn[i] = INF; que.push((node){1,0}); while(!que.empty()) { now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = d[now.k]; i; i = e[i].next) if(!vis[e[i].to] &amp;&amp; e[i].x &lt; minn[e[i].to]) { minn[e[i].to] = e[i].x; que.push((node){e[i].to,minn[e[i].to]}); } } for(re int i = 2; i &lt;= n; i++) ans = ans + minn[i]; printf("%d\n",ans); return 0;} 推荐例题：【模板】最小生成树]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言：线段树是一种二叉搜索树，能通关TA实现修改、区间查询等功能……（ 相信大家都懂的……）好吧，在这里，我们就来介绍线段树的单点修改、区间修改以及区间查询的方法。 单点修改，区间查询Emmmmmm 这算是学习线段树的第一步了吧…… _为什么要用线段树去干这件事情呢？你会发现，如果你直接暴力去查询一个区间 [l,r] 的和，那么这样做的时间复杂度将会使O(n)的；但是，如果你用线段树去实现这一过程，那么时间复杂度将会降成O(log n)。 _ 接下来我们就来讲算法的原理。既然线段树被称为“树”，自然是一种树状的数据结构。它的每一个节点都储存了某一个区间的信息。它的结构如图所示： 进行修改时，我们需要更新指定修改节点已经所以与其相关的区间（即包含此节点的所有区间），查询时需查询的区间的值可以有其内部的几个区间的值拼起来得到。代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;cstdio&gt;using namespace std;struct tree{ int sum; tree *lson,*rson;}*root=(tree*)malloc(sizeof(tree));int n,x,y,s,m;void built(tree *tre,int l,int r){ if(l==r) { scanf("%d",&amp;x); tre -&gt; sum = x; return ; } tree *left=(tree*)malloc(sizeof(tree)); tree *right=(tree*)malloc(sizeof(tree)); tre -&gt; lson=left; tre -&gt; rson=right; int mid=(l+r)&gt;&gt;1; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid+1,r); tre -&gt; sum=tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;}void change(tree *tre,int a,int x,int l,int r){ if(x==l&amp;&amp;x==r) { tre -&gt; sum+=a; return ; } tre -&gt; sum += a; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(tre -&gt; lson,a,x,l,mid); if(x&gt;mid) change(tre -&gt; rson,a,x,mid+1,r);}int query(tree *tre,int l,int r,int x,int y){ if(x&lt;=l&amp;&amp;y&gt;=r) return tre -&gt; sum; int mid=(l+r)&gt;&gt;1,ans1=0,ans2=0; if(x&lt;=mid) ans1=query(tre -&gt; lson,l,mid,x,y); if(y&gt;mid) ans2=query(tre -&gt; rson,mid+1,r,x,y); return ans1+ans2;}int main(){ scanf("%d%d",&amp;n,&amp;m); built(root,1,n); for(int i=1;i&lt;=m;i++) { scanf("%d%d%d",&amp;s,&amp;x,&amp;y); if(s==1) change(root,y,x,1,n); if(s==2) printf("%d\n",query(root,1,n,x,y)); } return 0;}// PS:我的线段树是用指针写的，如果不喜欢指针可以用数组去实现，节点N的左孩子的下标为2N，右孩子的下标为2N+1。 想做模板题请戳这里（请忽略题目名字，并不是我弄错了，一个模板题的潜力是无穷的） 区间修改，区间查询其实区间修改与单点修改之间只差了一个lazy标记……如果你用多次的单点修改来完成区间修改，那么复杂度将会是O（nlogn），显然还不如你直接修改一个数组快qwq……所以在这个紧急关头，你需要一个lazy标记去拯救你。对于每次区间修改，我们还是从根节点开始找每一个区间，若当前区间[l,r]被需要修改的区间[x,y]完全包含，那么在更新此区间的值的同时，我们还要更新lazy标记，表示该节点的两个子节点需要进行一个大小为lazy的值的修改，但是现在还没有进行。当你打完lazy标记以后，在此次修改中，你就不必再去观该节点的子树了。那么，既然我们打了lazy标记，那么以后肯定还是需要让它起作用的。我们在每次修改和查询过程中，若遍历到某点时，该点的lazy标记不为0，则把标记下放（即根据该节点的lazy标记值去修改其子节点的值，并把该节点的lazy加到其子节点的lazy上。注意，lazy的是加过去，而不是直接覆盖！在标记下放完以后，不要忘了把该节点的lazy标记清空）。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct tree{ long long sum,lazy; tree *lson,*rson; tree() { lazy = 0; }};long long x,y,k,n,m,s;void built(tree *tre,int l,int r){ tre -&gt; lazy = 0; if(l == r) { scanf("%d",&amp;x); tre -&gt; sum = x; return ; } int mid = (l + r) &gt;&gt; 1; tree *son1 =(tree*) malloc (sizeof(tree)); tree *son2 =(tree*) malloc (sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid + 1,r); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;}void pushdown(tree *tre,int l,int r){ if(l != r) { int mid = (l + r) &gt;&gt; 1; tre -&gt; lson -&gt; lazy = tre -&gt; lson -&gt; lazy + tre -&gt; lazy; tre -&gt; lson -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; lazy * (mid - l + 1); tre -&gt; rson -&gt; lazy = tre -&gt; rson -&gt; lazy + tre -&gt; lazy; tre -&gt; rson -&gt; sum = tre -&gt; rson -&gt; sum + tre -&gt; lazy * (r - mid); } tre -&gt; lazy = 0;}void change(tree *tre,int l,int r,int x,int y,int k){ if(l &gt;= x &amp;&amp; r &lt;= y) { tre -&gt; lazy += k; tre -&gt; sum = tre -&gt; sum + k * (r - l + 1); return ; } pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(tre -&gt; lson,l,mid,x,y,k); if(y &gt; mid) change(tre -&gt; rson,mid + 1,r,x,y,k); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt;sum;}long long query(tree *tre,int l,int r,int x,int y){ if(l &gt;= x &amp;&amp; r &lt;= y) return tre -&gt; sum; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; long long t1 = 0,t2 = 0; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return t1 + t2;}int main(){ scanf("%lld%lld",&amp;n,&amp;m); tree *root = (tree*) malloc (sizeof(tree)); built(root,1,n); for(int i = 1;i &lt;= m; i++) { scanf("%lld%lld%lld",&amp;s,&amp;x,&amp;y); if(s == 1) { scanf("%lld",&amp;k); change(root,1,n,x,y,k); } else { long long ans = query(root,1,n,x,y); printf("%lld\n",ans); } } return 0;} 想做模板题请戳这里 线段树除了求和还能干好多事情（如维护区间最大值等），可以自行YY一下下……]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ant Trip-题解]]></title>
    <url>%2F2019%2F06%2F20%2FAnt-Trip-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里因为每条边都只能走一次，所以这道题可以用欧拉路的性质来求解。我们首先用并查集去记录每一个联通块，然后再统计每一个子图的奇点数，如果是偶数则满足欧拉回路的性质直接ans++ 就好了，如果是奇数，那么需要的蚂蚁数则是奇点数/2附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register using namespace std;int read()&#123; register int a = 0,f = 1; register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &lt;='9' &amp;&amp; ch &gt;='0') &#123;a = a * 10 + ch - 48; ch = getchar();&#125; return a * f;&#125;int n,m,x,y,s,ans,cnt,t,d[100005],fa[100005],use[100005],a[100005],add[100005];int find(int p)&#123; if(fa[p] == p) return p; return fa[p] = find(fa[p]);&#125;void work()&#123; m = read(); ans = 0; for(re int i = 1; i &lt;= n; i++) fa[i] = i; for(re int i = 1; i &lt;= n; i++) d[i] = 0; for(re int i = 1; i &lt;= n; i++) a[i] = 0; for(re int i = 1; i &lt;= n; i++) add[i] = 0; for(re int i = 1; i &lt;= m; i++) &#123; x = read(); y = read(); d[x] ++; d[y] ++; if(find(x) != find(y)) fa[find(y)] = find(x); &#125; for(int i = 1; i&lt;= n; i++) &#123; a[find(i)]++; if(d[i] % 2 == 1) add[find(i)] ++; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt;= 1) continue; //只有一个点和空的点集没有边，可以忽略不计。 else if(add[i] == 0) ans += 1; else if(add[i] &gt; 0) ans += add[i]/2; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; while(cin &gt;&gt; n) work(); return 0;&#125;]]></content>
      <tags>
        <tag>欧拉</tag>
      </tags>
  </entry>
</search>
